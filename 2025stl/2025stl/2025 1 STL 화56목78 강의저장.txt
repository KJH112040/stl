// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::ofstream out{ "2025 1 STL 화56목78 강의저장.txt",std::ios::app };

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	/*
	char c;
	while (in >> c)			in>>c 고급I/O : in.operator>>(c)	, operator>>(in,c)
		out << c;
	*/
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;

}


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin());
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out });
}                  


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();	//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:03:14 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:06:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//	과제 - save를 save.cpp로 분리하라.
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:42:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view fileName);

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:48:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
	save("save.h");
	save("save.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.h													2025년 3월 11일
//----------------------------------------------------------------------------
#pragma once
void save(std::string_view);


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.cpp												2025년 3월 11일
//
//	한 학기 강의를 덧붙여 저장하는 함수 입니다.
//----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<chrono>

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
void change(int&, int&);

//---------
int main() 
//---------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:26:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

void change(int&, int&);
void change(Dog&, Dog&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}

void change(Dog& a, Dog& b) {
	Dog t{ a };
	a = b;		// a.operator=(b)
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:36:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template<class T>
void change(T&, T&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

template <class T>
void change(T& a, T& b) {
	T t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:54:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
// iostream standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _IOSTREAM_
#define _IOSTREAM_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <istream>
#include <ostream>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new
_STD_BEGIN
#ifdef _M_CEE_PURE
__PURE_APPDOMAIN_GLOBAL extern istream cin;
__PURE_APPDOMAIN_GLOBAL extern ostream cout;
__PURE_APPDOMAIN_GLOBAL extern ostream cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream clog;
__PURE_APPDOMAIN_GLOBAL extern istream* _Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern wistream wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream wclog;
__PURE_APPDOMAIN_GLOBAL extern wistream* _Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wclog;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream cin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream clog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream* _Ptr_cin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_clog;

_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream wcin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wclog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream* _Ptr_wcin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wclog;

#ifdef _CRTBLD // TRANSITION, ABI: _Winit appears to be unused
class _CRTIMP2_PURE_IMPORT _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;

private:
	__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;
};
#endif // defined(_CRTBLD)

#endif // ^^^ !defined(_M_CEE_PURE) ^^^
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _IOSTREAM_
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template <class T>
void change(T& a, T& b) 
{
	T t{ a };
	a = b;
	b = t;
}

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 1. change(Dog, Dog);
		// 2. change(Dog&, Dog&);
		// 3. 컴파일러가 template을 이용하여 코드 생성
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:07:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		if (i % 100 == 0)cout << '\n';
		cout << uid(dre) << " ";
		cout << endl;
	}
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:08:33 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:37:24 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{ random_device{}()};
uniform_int_distribution<int> uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	가장 큰 값을 찾아 화면에 출력하라

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:52:32 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	// T[N]
	int arr[1'000];
	for (int i = 0; i < 1000; ++i)
		arr[i] = uid(dre);
	
	int maxValue{ numeric_limits<int>::min() };
	
	for (int i = 0; i < 1000; ++i) {
		if (maxValue < arr[i])
			maxValue = arr[i];
	}
	
	cout << "최댓값 - " << maxValue << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:10:02 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	auto 위치 = max_element(arr.begin(), arr.end());
	
	cout << "최댓값 - " << *위치 << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:11:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	cout << "최댓값 - " << *max_element(arr.begin(), arr.end()) << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:25:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:<8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:26:13 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:^8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:31:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8}",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:37:31 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8} *** ",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:40:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	int count{};
	for (int i = 0; i < 1'000; ++i) {
		print(out, "{:8}", uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
		if (not(++count % 10))
			out << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:52:06 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num, maxValue{numeric_limits<int>::min()};
	size_t cnt{ };

	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	cout << "읽은 개수 - " << cnt << endl;
	cout << "최댓값 - " << maxValue << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:58:46 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값 - "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:59:12 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값: "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 5:10:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;/*, cnt{0};
	while (in >> num) {
		in >> arr[cnt];
		++cnt;
	}*/
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:35:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	랜덤 데이터를 생성하기
//							/	파일에 텍스트로 기록하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	random_device rd{};
	cout << "이 값은 추적 불가능" << endl;
	
	for (int i = 0; i < 100; ++i)
		cout << rd() << '\t';

	//ifstream in{ "int 1000개.txt" };
	//if (not in)
	//	return 20250313;

	//array<int, 1000> arr;
	//int num;/*, cnt{0};
	//while (in >> num) {
	//	in >> arr[cnt];
	//	++cnt;
	//}*/
	//for (int i = 0; i < 1000; ++i) {
	//	in >> num;
	//	arr[i] = num;
	//}

	//for (int num : arr)
	//	print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:36:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary io
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;

	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:45:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << "2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:46:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:47:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	cout << "10진수 - " << num << endl;
	cout << "16진수 - " << hex << num << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:55:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:56:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a{};

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:57:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	a.fill(333);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:59:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:00:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:01:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1234 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:12:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:14:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:17:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;
	// 기록 했을 때 메모리를 하나 더 잡아서? -> a의 int개수(size)는 그대로임.
	// 마지막 EOF는 파일 사이즈에 영향을 미치지 않음.

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로",ios::binary };			// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:20:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );
	a.fill(0x0a0a0a0a);

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로"};	
	// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	// 텍스트 모드는 인간이 눈으로 보는 걸 전제로 함. -> 보기 편하게 하기 위한 작업을 os가 해줌. (windows,unix?,Linux...)
	// windows가 치는 장난?
	
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:35:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<random>
#include "save.h"
using namespace std;

//	파일 "int 10만개를 바이너리모드 write함수로 기록" 에 10만개의 랜덤 int 값을 기록하자.
//	이 int값은 메모리 크기 그대로 기록되어 있다.
//	파일을 binary mode로 열자

default_random_engine dre;	// 5천 바이트 짜리임,,

//---------
int main() 
//---------
{
	ofstream out{ "int 10만개를 바이너리모드 write함수로 기록" , ios::binary };
	
	uniform_int_distribution uid{ numeric_limits<int>::min(), numeric_limits<int>::max() };

	int num;
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write((char*)&num, sizeof(int));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:59:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:00:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:36 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:03:02 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360 이거 값 바뀜;;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:09:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() {
		// 다음 시간에 만들어 보겠습니다.
	}
private:
	string name;		// 32
	size_t id;			// 8
};

//	Dog 만마리를 생성하여 파일에 저장(write). 메모리로 읽어와서 처리(정렬).

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:39:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	int min{ a[0]}, max{0};

	for (int num : a) {
		if (min > num)min = num;
		if (max < num)max = num;
	}

	cout << "가장 작은 값 - " << min << ", 가장 큰 값 - " << max << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:43:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	cout << "최댓값 - " << *max_element(a.begin(), a.end()) << endl;		//역참조 operator
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:49:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 int 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto p = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *p.first << endl;
	cout << "최댓값 - " << *p.second << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:51:23 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto [최솟값의위치, 최댓값의위치] = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *최솟값의위치 << endl;
	cout << "최댓값 - " << *최댓값의위치 << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:20 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

//	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
//		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:19 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}]", id);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - ", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:16:54 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {:15}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:17:16 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:18:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:21:33 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	ofstream out{ "Dog 10만마리",ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog,sizeof(Dog));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:40:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
	friend ostream& operator<<(ostream& os,const Dog& dog) {
		cout << "id - " << dog.id << ", name - " << dog.name << endl;
	}
private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	Dog dog;
	int cnt{};
	while (in.read((char*)&dog, sizeof(Dog))) {
		++cnt;
	}

	cout << "읽은 객체 수 - " << cnt << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:48:40 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};

	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name <<" - "<< dog.id << endl;
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	cout << dogs.back() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 5:02:48 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};


	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name << " - " << dog.id;
	}

	friend istream& operator>>(ifstream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	//	[문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs)
	{
		in >> dog;				// operator>>(in,dog)
		cout << dog << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:18:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10];

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:19:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:24:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	throw 20250325;
	
	cout << "이 줄이 출력되면 되겠니?" << endl;		//throw로 예외 집어넣어서 처리를 해주지 않으면 사망
	delete[]p;
}

//---------
int main() 
//---------
{
	try{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:27:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	delete[]p;

	//	시간이 얼마쯤 흐른 후

	//	delete[]p; 얘를 한 번더 부르면 p가 댕글링 ? 여하튼 프로그램 사망 
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:28:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	delete p;
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:29:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:34:31 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p{ new Dog };

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:38:27 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:39:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:41 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:42:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> p{ new Dog };		//	스택 언와이딩?
	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:44:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog>p=make_unique<Dog>();

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:40 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:48:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII : class로 자원을 관리하는 것, 클래스 생성할 때 자원을 연결 
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:02:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:03:11 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:04:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:10:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out},
		[](char c) {return toupper(c); });

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:28:00 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료 - FILE
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out},
		[](char c) {return toupper(c); });

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:32:22 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:54:26 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	array<int, 1'000'00> a;

	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//qsort(&a, a.size(), sizeof(int), [](int a, int b){})

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a | ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:55:12 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	array<int, 1'000'00> a;

	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//qsort(&a, a.size(), sizeof(int), [](int a, int b){})

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(5)
					| views::take(1)
		)
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:12:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	//	바꿔야 하면 1
	//	이미 정렬상태이면 -1
	//	둘이 정렬기준상 동일한 값이라면 0
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:17:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:17:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(3000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:21:19 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 내림차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:34:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	

	int(*정렬기준)(const void*, const void*) = 오름차순;			//	함수 포인터
	//	정렬기준 = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:41:01 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	

	//int(*정렬기준)(const void*, const void*) = 오름차순;			//	함수 포인터
	int(*정렬기준)(const void*, const void*) = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	//	원래는 save->("main.cpp") 이런 식으로 인자전달해야 하나 번거로워서? 약식 제공
	(*save)("main.cpp");		//	save라는 코드의 시작번지가 save임 사실 함수는 (*save)이고 이게 정식 코드
}


=================================================
저장한 시간: 2025-03-27 오후 4:46:43 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬
	sort(a.begin(), a.end());
	
	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:54:39 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬
	sort(a.begin(), a.end(), 오름차순);		//	default 정렬 operator <
	
	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:58:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:58:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:00:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::microseconds>(끝 - 시작) << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:01:21 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:04:35 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:10:07 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution<int> uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort<array<int,1'000'0000>::iterator>(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:26:04 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution<int> uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort<array<int,1'000'0000>::iterator>(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000)|views::reverse)
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:34:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?

	[]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:37:29 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?

	cout<< "람다의 정체 - "<<typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:39:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?
	//	람다의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>

	cout<< "람다 1의 정체 - "<<typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;

	cout << "람다 2의 정체 - " << typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:46:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?
	//	람다의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>
	//	람다 1의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>
	//	람다 2의 정체 - class `int __cdecl main(void)'::`2'::<lambda_2>

	[]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}();

	int* 저장 = (int*)save;
	cout <<"save함수가 저장된 메모리의 번지 - "
		<< 저장 << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:50:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {		// 함수 호출 연산자
		cout << "나를 왜 불렀죠?" << endl;
	}
};

//---------
int main() 
//---------
{
	Dog dog;

	dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:52:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {		// 함수 호출 연산자
		cout << "나를 왜 불렀죠?" << endl;
	}
};

//---------
int main() 
//---------
{
	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:53:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	class Dog {
	public:
		void operator()() {		// 함수 호출 연산자
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;
	//	class Dog가 전역일 때 : class Dog


	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:54:55 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	class Dog {
	public:
		void operator()() {		// 함수 호출 연산자
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;
	//	class Dog가 전역일 때 : class Dog
	//	class Dog가 지역일 때 : class `int __cdecl main(void)'::`2'::Dog


	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:14:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b)const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num<<' ';
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:14:40 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	auto Dog = [](int a, int b) -> bool {return a > b; };

	sort(a.begin(), a.end(), Dog);

	for (int num : a)
		cout << num << " ";
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:19:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.

	class Dog {
	public:	
		bool operator()(int a, int b){return a > b; };
	};

	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num << " ";
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:22:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:27:17 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;
	// false

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:31:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입	--------> 모든 것을 대표하는 function
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<functional>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;


	function<bool(int,int)> 내림차순 = p;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:39:09 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//---------
int main() 
//---------
{
	array<Dog, 10>dogs;

	for (const Dog& dog : dogs)
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:39:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//---------
int main() 
//---------
{
	array<Dog, 10>dogs;

	for (const Dog& dog : dogs)
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:47:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include<fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		//	cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}


private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

//	[문제] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//
//	ofstream out{ "Dog 십만마리" };
//
//	Dog dog;
//	out << dog;
//	ostream& operator<<(ostream&os,const Dog&og){
//		return os << dog.id << " " << dog.name << " ";
//	}

//---------
int main() 
//---------
{
	ofstream out{ "Dog 십만마리" };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:39:21 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
//#include<algorithm>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	int name_len() {
		return sizeof(name);
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	int num;
	string name;
	int cnt{};
	while (in >> num >> name) {
		println("[{:7}] - {:12} {}", ++cnt, num, name);
	}

	//in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	//cout << "마지막 객체의 정보 -" << dogs[9'9999] << endl;

	//sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.name_len() < b.name_len(); });

	//for (int i = 0; i < 1000; ++i)
	//	cout << dogs[i] << " ";
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:46:39 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
//#include<algorithm>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:58:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::take(1000))		// 코딩 겉멋이 들었다면 auto를 쓸텐데, 여기선 auto를 쓰더라도 const auto&로 써야함.
		dog.show();										// auto 쓸 때 없는 데에 쓰지 말라는 듯

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:59:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::reverse)		// 내림차로 출력해보기
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 4:06:25 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}

	bool operator<(const Dog& other) {
		return name.size() < other.name.size();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end());
	//	dogs.begin(), dogs.end() - 정렬할 데이터의 범위

	for (const Dog& dog : dogs | views::reverse)		// 내림차로 출력해보기
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 4:37:58 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

class STRING {

};

//---------
int main() 
//---------
{
	string s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 5:10:47 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

// public, private, protected ---> acssess modifiy모디파이?
class STRING {
public:
	STRING(const char* s) :len{strlen(s)} {		// [] (array) -> *(pointer)로 collapsing 
		// p = new char[len];	-> unique_ptr이기에 불가능한 작업, unique_ptr은 자원을 독점하는 놈
		p.reset();
		p = make_unique<char[]>(len);		// Lvalue : 현대식으로는 location value (left value아님...)
		memcpy(p.get(), s, len);					// DMA : Direct Memory Acssess
	};

	size_t size() const {
		return len;
	}
private:
	size_t len{};
	unique_ptr<char[]> p{};

	friend ostream& operator<<(ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	//	27
	//	std::string과 유사한 클래스

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	//STRING t;
	//t = s;

	//STRING u = s;

	//cout << t << endl;
	//cout << s << endl;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING(const char* s);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);
};


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"STRING.h"

STRING::STRING(const char* s) :len{ strlen(s) } 
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);
};

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}


=================================================
저장한 시간: 2025-04-08 오후 2:52:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	//STRING s{ "std::string과 유사한 클래스" };

	//cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	//cout << s << endl;

	//string t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	//t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	//string u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	//cout << t << endl;
	//cout << u << endl;

	STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:54:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	//STRING s{ "std::string과 유사한 클래스" };

	//cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	//cout << s << endl;

	//string t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	//t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	//string u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	//cout << t << endl;
	//cout << u << endl;

	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

//STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	STRING t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	STRING u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	cout << t << endl;
	cout << u << endl;

	//cout << "메인 시작" << endl;
	//STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
static bool 관찰{ true };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 2:57:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰 = false;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{

	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:07:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	//관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() > b.size();
	});

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:08:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	//관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:08:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});
	관찰 = false;

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});
	관찰 = false;

	관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ true };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 3:12:32 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << s << endl;
	cout << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:51:08 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:52:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:53:31 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:55:08 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	
	// 이동의미?법  move simentic? 무브 시멘틱

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	
	// move semantic

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0xb52d31fb90, 자원메모리 : 0x26901493880
	//[2] 이동생성자, 자원수 : 11, 메모리 : 0xb52d31fba8, 자원메모리 : 0x26901493880
		
	// move semantic

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//t - 표준 string

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1516 bytes"
	//"2025 1 STL 화56목78 강의저장.txt에 STRING.h을 덧붙였습니다. - 1115 bytes"
	//"2025 1 STL 화56목78 강의저장.txt에 STRING.cpp을 덧붙였습니다. - 2950 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0xb52d31fba8, 자원메모리 : 0x26901493880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0xb52d31fb90, 자원메모리 : 0x0
}


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:46:13 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬

	// 출력
	관찰 = true;
	for (const STRING& str:a)
		cout << str << endl;
	관찰 = false;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:00:49 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});

	// 출력
	관찰 = true;
	for (const STRING& str:a)
		cout << str << endl;
	관찰 = false;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:01:34 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});
	관찰 = false;

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:04:18 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});
	관찰 = false;
	//	[6] 이동생성자,		자원수 : 3,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2480
	//	[2] 이동할당연산자,	자원수 : 3,	메모리 : 0x1574cffb38, 자원메모리 : 0x1c6a6ab2480
	//	[6] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[7] 이동생성자,		자원수 : 5,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2450
	//	[3] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb50, 자원메모리 : 0x1c6a6ab2450
	//	[7] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[8] 이동생성자,		자원수 : 2,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab25d0
	//	[4] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb68, 자원메모리 : 0x1c6a6ab2450
	//	[3] 이동할당연산자,	자원수 : 3,	메모리 : 0x1574cffb50, 자원메모리 : 0x1c6a6ab2480
	//	[2] 이동할당연산자,	자원수 : 2,	메모리 : 0x1574cffb38, 자원메모리 : 0x1c6a6ab25d0
	//	[8] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[9] 이동생성자,		자원수 : 4,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2580
	//	[5] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb80, 자원메모리 : 0x1c6a6ab2450
	//	[4] 이동할당연산자,	자원수 : 4,	메모리 : 0x1574cffb68, 자원메모리 : 0x1c6a6ab2580
	//	[9] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0

	// 출력
	for (const STRING& str : a)
		cout << str << endl;
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:17:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v;
	vector<vector<string>> vv;
	vector<vector<vector<int>>> vvv;		// 이렇게 까지 코딩하진 않음.

	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:25:46 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:26:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl; // value 타입 - int

	cout << "빈 array니?" << boolalpha << a.empty() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:30:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl; // value 타입 - int

	cout << "빈 array니? - " << boolalpha << a.empty() << endl;			// 빈 array니? - true

	array<int, 5> aa{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << aa[i] << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:36:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 5> a{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << a[i] << endl;			//	930484408
										//	32759
										//	1109086144
										//	32766
										//	1109086144
										//	32766
										//	0
										//	0
										//	0
										//	0
										//	1
										//	2
										//	3
										//	4
										//	5
										//	0
										//	0
										//	0
										//	- 1484893439
										//	59818
	cout << "몇 번째? - ";

	START:

	int num;
	cin >> num;

	try {
		a.at(num);
	}
	catch (std::exception& e) {
		cout << e.what() << endl;
		cout << "다시 입력해" << endl;
		goto START;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:36:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 5> a{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << a[i] << endl;			//	930484408
										//	32759
										//	1109086144
										//	32766
										//	1109086144
										//	32766
										//	0
										//	0
										//	0
										//	0
										//	1
										//	2
										//	3
										//	4
										//	5
										//	0
										//	0
										//	0
										//	- 1484893439
										//	59818
	cout << "몇 번째? - ";				// 입력: 3 -> 종료, 입력: 100 -> "다시 입력해" 후 START로 돌아감.

	START:

	int num;
	cin >> num;

	try {
		a.at(num);
	}
	catch (std::exception& e) {
		cout << e.what() << endl;
		cout << "다시 입력해" << endl;
		goto START;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:40:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{1,2,3};			// {} - initializer-list

	for (int num : {1, 2, 3, 4, 5})
		cout << num << endl;

	//1
	//2
	//3
	//4
	//5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:43:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{1,2,3};			// {} - initializer-list
	// vector<int> v(100); 와 위 v는 다름.

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:46:11 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> *p = new vector<int>{ 1,2,3 };			// {} - initializer-list

	// vector<int> v(100); 와 위 v는 다름.

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof *p << endl;
	cout << "v의 주소 - " << addressof(*p) << endl;
	cout << "v의 타입 - " << typeid(*p).name() << endl;
	//	v의 크기 - 24
	//	v의 주소 - 0000005217D3FA40
	//	v의 타입 - class std::vector<int, class std::allocator<int> >

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (vector<int>::iterator i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:03:09 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (auto i = v.cbegin(); i != v.cend(); ++i)
		cout << *i << endl;
	//	1
	//	2
	//	3

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:03:54 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (auto i = v.crbegin(); i != v.crend(); ++i)
		cout << *i << endl;
	//	3
	//	2
	//	1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:12:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//---------
int main() 
//---------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);		// 0(zero) long long
	cout << "합계 - " << sum <<endl;
	cout << "평균 - " << (double)sum / v.size() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 3:42:01 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	키보드에서 입력한 단어를 오름차순 정렬한 후 출력하라.	ctrl + z : 입력 종료 키

//---------
int main() 
//---------
{
	vector<std::string> v{ istream_iterator<string>{cin},{} };		// 키보드 입력 시작/끝

	sort(v.begin(), v.end());			// (시험 문제로 나올 수 있음)sort가 왜 정렬되는지? 클래스 애들은 어떻게 정렬하는지???

	for (const std::string& str : v)
		cout << str << endl;

	//	동해물과 백두산이 마르고 닳도록 하느님잉 보우하사 우리나라 만세
	//	무궁화 삼천리 화려강산 대한 사람 대한으로 긱ㄹ이 보전하세
	//	남산 위에 저 소나무 철갑을
	//	^ Z
	//	긱ㄹ이
	//	남산
	//	닳도록
	//	대한
	//	대한으로
	//	동해물과
	//	마르고
	//	만세
	//	무궁화
	//	백두산이
	//	보우하사
	//	보전하세
	//	사람
	//	삼천리
	//	소나무
	//	우리나라
	//	위에
	//	저
	//	철갑을
	//	하느님잉
	//	화려강산

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 3:53:15 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?

//---------
int main() 
//---------
{
	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량 - " << v.capacity() << endl;
	cout << "메모리 - " << v.data() << endl;

	v.push_back(1);
	cout << "원소를 한 개 추가한 후 v의 내용" << endl;
	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량 - " << v.capacity() << endl;
	cout << "메모리 - " << v.data() << endl;

	//	원소 개수 - 0
	//	용량 - 0
	//	메모리 - 0000000000000000
	//	원소를 한 개 추가한 후 v의 내용
	//	원소 개수 - 1
	//	용량 - 1
	//	메모리 - 000001FAB1552200
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:04:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?

//---------
int main() 
//---------
{
	vector<int> v;

	for (int i = 0; i < 10;++i) {
		cout << "--------------------------------------" << endl;
		cout << "원소 개수 - " << v.size() << endl;
		cout << "용량 - " << v.capacity() << endl;
		cout << "메모리 - " << v.data() << endl;

		v.push_back(1);
		cout << endl;
	}

	//--------------------------------------
	//	원소 개수 - 0
	//	용량 - 0
	//	메모리 - 0000000000000000
	//	--------------------------------------
	//	원소 개수 - 1
	//	용량 - 1
	//	메모리 - 000001D8614A24F0				// 새로운 메모리가 reallocation?
	//	--------------------------------------
	//	원소 개수 - 2
	//	용량 - 2
	//	메모리 - 000001D8614A2490
	//	--------------------------------------
	//	원소 개수 - 3
	//	용량 - 3
	//	메모리 - 000001D8614A2890
	//	--------------------------------------
	//	원소 개수 - 4
	//	용량 - 4
	//	메모리 - 000001D8614A29B0
	//	--------------------------------------
	//	원소 개수 - 5
	//	용량 - 6
	//	메모리 - 000001D8614A2D70				// 여기서부터 원소 개수 6까지는 메모리 주소가 변하지 않음 : 용량이 여유가 있어서
	//	--------------------------------------
	//	원소 개수 - 6
	//	용량 - 6
	//	메모리 - 000001D8614A2D70
	//	--------------------------------------
	//	원소 개수 - 7
	//	용량 - 9
	//	메모리 - 000001D86149F400				// 여기서 다시 한 번 메모리가 바뀌었다가 이 후 또 메모리 주소 변하지 않음.
	//	--------------------------------------
	//	원소 개수 - 8
	//	용량 - 9
	//	메모리 - 000001D86149F400
	//	--------------------------------------
	//	원소 개수 - 9
	//	용량 - 9
	//	메모리 - 000001D86149F400

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:18:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	vector<int> v;
	size_t old = v.capacity();

	for (int i = 0; i < 1'0000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "원소 수	- " << v.size() << endl;
			cout << "용량	- " << v.capacity() << endl;
			old = v.capacity();
		}
	}
	//	원소 수 - 1
	//	용량 - 1
	//	원소 수 - 2
	//	용량 - 2
	//	원소 수 - 3
	//	용량 - 3
	//	원소 수 - 4
	//	용량 - 4
	//	원소 수 - 5
	//	용량 - 6
	//	원소 수 - 7
	//	용량 - 9
	//	원소 수 - 10
	//	용량 - 13
	//	원소 수 - 14
	//	용량 - 19
	//	원소 수 - 20
	//	용량 - 28
	//	원소 수 - 29
	//	용량 - 42
	//	원소 수 - 43
	//	용량 - 63
	//	원소 수 - 64
	//	용량 - 94
	//	원소 수 - 95
	//	용량 - 141
	//	원소 수 - 142
	//	용량 - 211
	//	원소 수 - 212
	//	용량 - 316
	//	원소 수 - 317
	//	용량 - 474
	//	원소 수 - 475
	//	용량 - 711
	//	원소 수 - 712
	//	용량 - 1066
	//	원소 수 - 1067
	//	용량 - 1599
	//	원소 수 - 1600
	//	용량 - 2398
	//	원소 수 - 2399
	//	용량 - 3597
	//	원소 수 - 3598
	//	용량 - 5395
	//	원소 수 - 5396
	//	용량 - 8092
	//	원소 수 - 8093
	//	용량 - 12138
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:19:15 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	vector<int> v;
	size_t old = v.capacity();

	for (int i = 0; i < 1'0000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "용량	- " << v.capacity() << endl;
			old = v.capacity();
		}
	}
	//	용량이 0.5씩 늘어나고 있음. 무조건 0.5씩 늘려나가는 것은 아님.
	//	컴파일러 회사마다 조금 다름. visual studio에서는 0.5씩 늘림.
	//	용량 - 1
	//	용량 - 2
	//	용량 - 3
	//	용량 - 4
	//	용량 - 6
	//	용량 - 9
	//	용량 - 13
	//	용량 - 19
	//	용량 - 28
	//	용량 - 42
	//	용량 - 63
	//	용량 - 94
	//	용량 - 141
	//	용량 - 211
	//	용량 - 316
	//	용량 - 474
	//	용량 - 711
	//	용량 - 1066
	//	용량 - 1599
	//	용량 - 2398
	//	용량 - 3597
	//	용량 - 5395
	//	용량 - 8092
	//	용량 - 12138
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 5:02:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;
	
	//	v.push_back(STRING{ "12345" });
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x1816cffcc0, 자원메모리 : 0x2041a1d25a0
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x2041a1d28d0, 자원메모리 : 0x2041a1d25a0
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x1816cffcc0, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1430 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x2041a1d28d0, 자원메모리 : 0x2041a1d25a0

	//	v.push_back(move(STRING{ "12345" }));
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x49c9b1f750, 자원메모리 : 0x18e71d82520
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x18e71d828f0, 자원메모리 : 0x18e71d82520
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x49c9b1f750, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 995 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x18e71d828f0, 자원메모리 : 0x18e71d82520

	//	v.emplace_back(STRING{ "12345" });				// emplacing은 재료만 주면 됨.
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x368b8ffa40, 자원메모리 : 0x1ee649224c0
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x1ee64922c90, 자원메모리 : 0x1ee649224c0
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x368b8ffa40, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1869 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x1ee64922c90, 자원메모리 : 0x1ee649224c0

	//	v.emplace_back("12345");						// 임시 객체를 만들지 않음
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x1f9b2f226d0, 자원메모리 : 0x1f9b2f22530
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 2332 bytes"
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x1f9b2f226d0, 자원메모리 : 0x1f9b2f22530

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 5:10:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back("인자만 인자만 인자만");			// 객체가 만들어지는 형태 v.emplace_back(STRING{}) 로 쓰면 안됨. 재료(인자만) 써야함.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:34:38 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;
	
	v.emplace_back();
	v.emplace_back("인자만 인자만 인자만");			// 객체가 만들어지는 형태 v.emplace_back(STRING{}) 로 쓰면 안됨. 재료(인자만) 써야함.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:49:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	vector<STRING> v;
	
	//	v에 최대 얼마만큼의 원소를 저장할 것인지 예측한다.
	//	예측한 만큼 공간을 확보한다 -> reserve

	ifstream in{ "main.cpp" };

	array<int, 26> a;	// 빈도

	for (int n : a)
		cout << n << " ";
	cout << endl;
	//	-85258456 32767 904872880 32758 2 32758 2 0 904877496 32758 904868685 32758 0 0 0 0 63 0 0 0 904877488 32758 904868549 32758 7 0
	//	초기화 되지 않음.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:50:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	vector<STRING> v;
	
	//	v에 최대 얼마만큼의 원소를 저장할 것인지 예측한다.
	//	예측한 만큼 공간을 확보한다 -> reserve

	ifstream in{ "main.cpp" };

	array<int, 26> a{};	// 빈도

	for (int n : a)
		cout << n << " ";
	cout << endl;
	//	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	//	초기화 됨.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:53:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	array<int, 26> a{};	// 빈도

	ifstream in{ "main.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}

	for (int i = 0; i < a.size(); ++i)
		cout << static_cast<char>(i + 'a') << " -> " << a[i] << endl;

//	a -> 36
//	b -> 4
//	c -> 26
//	d -> 9
//	e -> 36
//	f -> 5
//	g -> 1
//	h -> 7
//	i -> 33
//	j -> 2
//	k -> 0
//	l -> 10
//	m -> 10
//	n -> 29
//	o -> 15
//	p -> 7
//	q -> 2
//	r -> 27
//	s -> 16
//	t -> 25
//	u -> 12
//	v -> 4
//	w -> 2
//	x -> 1
//	y -> 6
//	z -> 2

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:59:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.
	remove(v.begin(), v.end(), 3);		// algorithm

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	1 2 4 5 5

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:07:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.
	auto new_end = remove(v.begin(), v.end(), 3);		// algorithm
	v.erase(new_end, v.end());

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	1 2 4 5

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:11:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.	erase-remove idiom
	v.erase(remove(v.begin(), v.end(), 3), v.end());
	//	원칙을 깨는 함수가 만들어짐 (vector 전용 함수, c++20부터 제공)
	erase(v, 3);
	//	STL하면서 교수님께서 싫어하는 함수(원칙을 깨서?)

	for (int num : v)
		cout << num << ' ';
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:23:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 홀수를 제거하라.
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return n & 1;
	}), v.end());

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	2 4

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:25:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 홀수를 제거하라.
	erase_if(v, [](int n) {
		return n & 1;
	});
	// 축약 버전

	for (int num : v)
		cout << num << ' ';
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;

	// 인터페이스 함수들
	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","3","4","5"};

	//	[문제] v에서 "3"을 제거하라.
	v.erase(remove(v.begin(), v.end(), "3"), v.end());

	for (const STRING& s : v)
		cout << s << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:42:00 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","3","4","5"};

	//	[문제] v에서 "3"을 제거하라.
	v.erase(remove(v.begin(), v.end(), "3"), v.end());

	cout << "v의 원소 수 - " << v.size() << endl;
	for (const STRING& s : v)
		cout << s << endl;
	//	1
	//	2
	//	4
	//	5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:44:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v)
		cout << s << endl;
	//	1
	//	2
	//	3
	//	4
	//	5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:45:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v)
		cout << s << endl;
	//	[1] 생성자(char*), 자원수:1, 메모리 : 0x2fe70ff7b0, 자원메모리 : 0x1f53fb308a0
	//	[2] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7c8, 자원메모리 : 0x1f53fb308b0
	//	[3] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7e0, 자원메모리 : 0x1f53fb30810
	//	[4] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7f8, 자원메모리 : 0x1f53fb30830
	//	[5] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2ae80, 자원메모리 : 0x1f53fb30970
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2ae98, 자원메모리 : 0x1f53fb30950
	//	[7] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2aeb0, 자원메모리 : 0x1f53fb307f0
	//	[8] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2aec8, 자원메모리 : 0x1f53fb30930
	//	[4] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7f8, 자원메모리 : 0x1f53fb30830
	//	[3] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7e0, 자원메모리 : 0x1f53fb30810
	//	[2] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7c8, 자원메모리 : 0x1f53fb308b0
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7b0, 자원메모리 : 0x1f53fb308a0
	//	[9] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff770, 자원메모리 : 0x1f53fb30890
	//	[10] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282f0, 자원메모리 : 0x1f53fb30890
	//	[11] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282c0, 자원메모리 : 0x1f53fb30970
	//	[12] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282d8, 자원메모리 : 0x1f53fb30950
	//	[13] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb28308, 자원메모리 : 0x1f53fb307f0
	//	[14] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb28320, 자원메모리 : 0x1f53fb30930
	//	[5] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2ae80, 자원메모리 : 0x0
	//	[6] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2ae98, 자원메모리 : 0x0
	//	[7] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2aeb0, 자원메모리 : 0x0
	//	[8] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2aec8, 자원메모리 : 0x0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff770, 자원메모리 : 0x0
	//	1
	//	2
	//	3
	//	4
	//	5
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1060 bytes"
	//	[11] 소멸자, 자원수:1, 메모리 : 0x1f53fb282c0, 자원메모리 : 0x1f53fb30970
	//	[12] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb282d8, 자원메모리 : 0x1f53fb30950
	//	[10] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb282f0, 자원메모리 : 0x1f53fb30890
	//	[13] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb28308, 자원메모리 : 0x1f53fb307f0
	//	[14] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb28320, 자원메모리 : 0x1f53fb30930
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:46:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	v.insert(v.begin() + 2, "3");
	관찰 = false;
	//	[9] 생성자(char*), 자원수:1, 메모리 : 0x69b78ff860, 자원메모리 : 0x1d7e35b2590
	//	[10] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0f0, 자원메모리 : 0x1d7e35b2590
	//	[11] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0c0, 자원메모리 : 0x1d7e35b2580
	//	[12] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0d8, 자원메모리 : 0x1d7e35b2460
	//	[13] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab108, 자원메모리 : 0x1d7e35b2470
	//	[14] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab120, 자원메모리 : 0x1d7e35b24d0
	//	[5] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aab80, 자원메모리 : 0x0
	//	[6] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aab98, 자원메모리 : 0x0
	//	[7] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aabb0, 자원메모리 : 0x0
	//	[8] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aabc8, 자원메모리 : 0x0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x69b78ff860, 자원메모리 : 0x0

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:49:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "3"을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	//	[9] 생성자(char*), 자원수:1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e8824e0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e8824e0
	//	[10] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[10] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[11] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882520
	//	[11] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882520
	//	[12] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[12] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:52:33 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","333","4444","55555"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "3"을 제거하라.
	관찰 = true;
	remove(v.begin(), v.end(), "333");
	관찰 = false;
	//	[11] 생성자(char*), 자원수:3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122590
	//	[11] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122590
	//	[12] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122430
	//	[12] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122430
	//	[13] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e6271224f0
	//	[13] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e6271224f0
	//	[14] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122490
	//	[14] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122490
	//	[8] 이동할당연산자, 자원수 : 4, 메모리 : 0x1e6271239d0, 자원메모리 : 0x1e627122420
	//	[15] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122470
	//	[15] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122470
	//	[9] 이동할당연산자, 자원수 : 5, 메모리 : 0x1e627123cd0, 자원메모리 : 0x1e6271224b0

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:54:41 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++ ++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	//	[9] 생성자(char*), 자원수:3, 메모리 : 0x51ad30fd70, 자원메모리 : 0x17e1a4b24d0
	//	[10] 이동생성자, 자원수 : 3, 메모리 : 0x17e1a4b3910, 자원메모리 : 0x17e1a4b24d0
	//	[9] 소멸자, 자원수 : 3, 메모리 : 0x51ad30fd70, 자원메모리 : 0x0
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:56:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};

	//	[문제] v에서 "333"을 삽입하라.
	STRING temp{ "333" };
	관찰 = true;
	v.insert(++ ++v.begin(), temp);
	관찰 = false;
	//	[      10] 복사생성자      , 자원수:3         , 메모리:0x1c618753e80, 자원메모리:0x1c618752570

	for (const STRING& s : v)
		cout << s << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:56:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};

	//	[문제] v에서 "333"을 삽입하라.
	관찰 = true;
	v.emplace(++++v.begin(), "333");
	관찰 = false;
	//	[       9] 생성자(char*)   , 자원수:3         , 메모리:0x17af8c93b20, 자원메모리:0x17af8c925a0

	for (const STRING& s : v)
		cout << s << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:00:28 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d;
	// array 제외 전부 동적 메모리 관리
	
	cout << "VS에서 x64일때 deque의 크기 - " << sizeof d << endl;
	//	VS에서 x64일때 deque의 크기 - 40

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:02:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d{"1","22","333","4444","55555"};
	// array 제외 전부 동적 메모리 관리
	
	for (int i = 0; i < d.size(); ++i)
		cout << &d[i] << endl;
	//	0000021975DA2B90
	//	0000021975DA2B10
	//	0000021975DA2B30
	//	0000021975DA2CB0
	//	0000021975DA2A50
	//	얘들이 같은 contigous메모리에 있어야 하는데 이상하다 라고 하셨습니다.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:05:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;
	deque<STRING> d{"1","22","333","4444","55555"};
	// array 제외 전부 동적 메모리 관리
	관찰 = false;

	for (int i = 0; i < d.size(); ++i)
		cout << &d[i] << endl;

	//	[1] 생성자(char*), 자원수:1, 메모리 : 0xc6b86ffb10, 자원메모리 : 0x2b01adf24e0
	//	[2] 생성자(char*), 자원수 : 2, 메모리 : 0xc6b86ffb28, 자원메모리 : 0x2b01adf2480
	//	[3] 생성자(char*), 자원수 : 3, 메모리 : 0xc6b86ffb40, 자원메모리 : 0x2b01adf2510
	//	[4] 생성자(char*), 자원수 : 4, 메모리 : 0xc6b86ffb58, 자원메모리 : 0x2b01adf25a0
	//	[5] 생성자(char*), 자원수 : 5, 메모리 : 0xc6b86ffb70, 자원메모리 : 0x2b01adf25b0
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x2b01adf2af0, 자원메모리 : 0x2b01adf2500
	//	[7] 복사생성자, 자원수 : 2, 메모리 : 0x2b01adf2b50, 자원메모리 : 0x2b01adf2520
	//	[8] 복사생성자, 자원수 : 3, 메모리 : 0x2b01adf2c90, 자원메모리 : 0x2b01adf24a0
	//	[9] 복사생성자, 자원수 : 4, 메모리 : 0x2b01adf2d30, 자원메모리 : 0x2b01adf2470
	//	[10] 복사생성자, 자원수 : 5, 메모리 : 0x2b01adf29d0, 자원메모리 : 0x2b01adf2420
	//	[5] 소멸자, 자원수 : 5, 메모리 : 0xc6b86ffb70, 자원메모리 : 0x2b01adf25b0
	//	[4] 소멸자, 자원수 : 4, 메모리 : 0xc6b86ffb58, 자원메모리 : 0x2b01adf25a0
	//	[3] 소멸자, 자원수 : 3, 메모리 : 0xc6b86ffb40, 자원메모리 : 0x2b01adf2510
	//	[2] 소멸자, 자원수 : 2, 메모리 : 0xc6b86ffb28, 자원메모리 : 0x2b01adf2480
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0xc6b86ffb10, 자원메모리 : 0x2b01adf24e0
	//	000002B01ADF2AF0
	//	000002B01ADF2B50
	//	000002B01ADF2C90
	//	000002B01ADF2D30
	//	000002B01ADF29D0

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:07:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d{"1","22","333","4444","55555"};

	d.push_front("0");
	d.push_front("-1");

	for (const STRING& d : d)
		cout << d << endl;

	//	-1
	//	0
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:09:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;
	deque<STRING> d{"1","22","333","4444","55555"};

	for (const STRING& s : d)
		cout << (void*)&s << endl;
	관찰 = false;

	//	[1] 생성자(char*), 자원수:1, 메모리 : 0x1cedddf7b0, 자원메모리 : 0x12b24902450
	//	[2] 생성자(char*), 자원수 : 2, 메모리 : 0x1cedddf7c8, 자원메모리 : 0x12b24902460
	//	[3] 생성자(char*), 자원수 : 3, 메모리 : 0x1cedddf7e0, 자원메모리 : 0x12b249025a0
	//	[4] 생성자(char*), 자원수 : 4, 메모리 : 0x1cedddf7f8, 자원메모리 : 0x12b24902540
	//	[5] 생성자(char*), 자원수 : 5, 메모리 : 0x1cedddf810, 자원메모리 : 0x12b24902580
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x12b24902db0, 자원메모리 : 0x12b249025b0
	//	[7] 복사생성자, 자원수 : 2, 메모리 : 0x12b24902930, 자원메모리 : 0x12b24902550
	//	[8] 복사생성자, 자원수 : 3, 메모리 : 0x12b24902ef0, 자원메모리 : 0x12b249024f0
	//	[9] 복사생성자, 자원수 : 4, 메모리 : 0x12b24902ad0, 자원메모리 : 0x12b24902590
	//	[10] 복사생성자, 자원수 : 5, 메모리 : 0x12b24902f70, 자원메모리 : 0x12b24902440
	//	[5] 소멸자, 자원수 : 5, 메모리 : 0x1cedddf810, 자원메모리 : 0x12b24902580
	//	[4] 소멸자, 자원수 : 4, 메모리 : 0x1cedddf7f8, 자원메모리 : 0x12b24902540
	//	[3] 소멸자, 자원수 : 3, 메모리 : 0x1cedddf7e0, 자원메모리 : 0x12b249025a0
	//	[2] 소멸자, 자원수 : 2, 메모리 : 0x1cedddf7c8, 자원메모리 : 0x12b24902460
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0x1cedddf7b0, 자원메모리 : 0x12b24902450
	// 해당 문제는 시험보고 나서 찾아볼 것

	save("main.cpp");
}