// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::ofstream out{ "2025 1 STL 화56목78 강의저장.txt",std::ios::app };

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	/*
	char c;
	while (in >> c)			in>>c 고급I/O : in.operator>>(c)	, operator>>(in,c)
		out << c;
	*/
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;

}


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin());
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out });
}                  


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();	//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:03:14 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:06:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//	과제 - save를 save.cpp로 분리하라.
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:42:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view fileName);

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:48:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
	save("save.h");
	save("save.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.h													2025년 3월 11일
//----------------------------------------------------------------------------
#pragma once
void save(std::string_view);


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.cpp												2025년 3월 11일
//
//	한 학기 강의를 덧붙여 저장하는 함수 입니다.
//----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<chrono>

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
void change(int&, int&);

//---------
int main() 
//---------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:26:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

void change(int&, int&);
void change(Dog&, Dog&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}

void change(Dog& a, Dog& b) {
	Dog t{ a };
	a = b;		// a.operator=(b)
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:36:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template<class T>
void change(T&, T&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

template <class T>
void change(T& a, T& b) {
	T t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:54:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
// iostream standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _IOSTREAM_
#define _IOSTREAM_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <istream>
#include <ostream>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new
_STD_BEGIN
#ifdef _M_CEE_PURE
__PURE_APPDOMAIN_GLOBAL extern istream cin;
__PURE_APPDOMAIN_GLOBAL extern ostream cout;
__PURE_APPDOMAIN_GLOBAL extern ostream cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream clog;
__PURE_APPDOMAIN_GLOBAL extern istream* _Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern wistream wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream wclog;
__PURE_APPDOMAIN_GLOBAL extern wistream* _Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wclog;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream cin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream clog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream* _Ptr_cin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_clog;

_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream wcin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wclog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream* _Ptr_wcin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wclog;

#ifdef _CRTBLD // TRANSITION, ABI: _Winit appears to be unused
class _CRTIMP2_PURE_IMPORT _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;

private:
	__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;
};
#endif // defined(_CRTBLD)

#endif // ^^^ !defined(_M_CEE_PURE) ^^^
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _IOSTREAM_
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template <class T>
void change(T& a, T& b) 
{
	T t{ a };
	a = b;
	b = t;
}

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 1. change(Dog, Dog);
		// 2. change(Dog&, Dog&);
		// 3. 컴파일러가 template을 이용하여 코드 생성
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:07:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		if (i % 100 == 0)cout << '\n';
		cout << uid(dre) << " ";
		cout << endl;
	}
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:08:33 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:37:24 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{ random_device{}()};
uniform_int_distribution<int> uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	가장 큰 값을 찾아 화면에 출력하라

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:52:32 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	// T[N]
	int arr[1'000];
	for (int i = 0; i < 1000; ++i)
		arr[i] = uid(dre);
	
	int maxValue{ numeric_limits<int>::min() };
	
	for (int i = 0; i < 1000; ++i) {
		if (maxValue < arr[i])
			maxValue = arr[i];
	}
	
	cout << "최댓값 - " << maxValue << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:10:02 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	auto 위치 = max_element(arr.begin(), arr.end());
	
	cout << "최댓값 - " << *위치 << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:11:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	cout << "최댓값 - " << *max_element(arr.begin(), arr.end()) << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:25:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:<8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:26:13 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:^8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:31:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8}",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:37:31 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8} *** ",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:40:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	int count{};
	for (int i = 0; i < 1'000; ++i) {
		print(out, "{:8}", uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
		if (not(++count % 10))
			out << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:52:06 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num, maxValue{numeric_limits<int>::min()};
	size_t cnt{ };

	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	cout << "읽은 개수 - " << cnt << endl;
	cout << "최댓값 - " << maxValue << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:58:46 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값 - "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:59:12 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값: "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 5:10:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;/*, cnt{0};
	while (in >> num) {
		in >> arr[cnt];
		++cnt;
	}*/
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:35:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	랜덤 데이터를 생성하기
//							/	파일에 텍스트로 기록하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	random_device rd{};
	cout << "이 값은 추적 불가능" << endl;
	
	for (int i = 0; i < 100; ++i)
		cout << rd() << '\t';

	//ifstream in{ "int 1000개.txt" };
	//if (not in)
	//	return 20250313;

	//array<int, 1000> arr;
	//int num;/*, cnt{0};
	//while (in >> num) {
	//	in >> arr[cnt];
	//	++cnt;
	//}*/
	//for (int i = 0; i < 1000; ++i) {
	//	in >> num;
	//	arr[i] = num;
	//}

	//for (int num : arr)
	//	print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:36:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary io
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;

	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:45:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << "2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:46:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:47:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	cout << "10진수 - " << num << endl;
	cout << "16진수 - " << hex << num << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:55:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:56:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a{};

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:57:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	a.fill(333);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:59:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:00:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:01:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1234 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:12:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:14:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:17:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;
	// 기록 했을 때 메모리를 하나 더 잡아서? -> a의 int개수(size)는 그대로임.
	// 마지막 EOF는 파일 사이즈에 영향을 미치지 않음.

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로",ios::binary };			// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:20:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );
	a.fill(0x0a0a0a0a);

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로"};	
	// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	// 텍스트 모드는 인간이 눈으로 보는 걸 전제로 함. -> 보기 편하게 하기 위한 작업을 os가 해줌. (windows,unix?,Linux...)
	// windows가 치는 장난?
	
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:35:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<random>
#include "save.h"
using namespace std;

//	파일 "int 10만개를 바이너리모드 write함수로 기록" 에 10만개의 랜덤 int 값을 기록하자.
//	이 int값은 메모리 크기 그대로 기록되어 있다.
//	파일을 binary mode로 열자

default_random_engine dre;	// 5천 바이트 짜리임,,

//---------
int main() 
//---------
{
	ofstream out{ "int 10만개를 바이너리모드 write함수로 기록" , ios::binary };
	
	uniform_int_distribution uid{ numeric_limits<int>::min(), numeric_limits<int>::max() };

	int num;
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write((char*)&num, sizeof(int));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:59:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:00:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:36 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:03:02 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360 이거 값 바뀜;;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:09:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() {
		// 다음 시간에 만들어 보겠습니다.
	}
private:
	string name;		// 32
	size_t id;			// 8
};

//	Dog 만마리를 생성하여 파일에 저장(write). 메모리로 읽어와서 처리(정렬).

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:39:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	int min{ a[0]}, max{0};

	for (int num : a) {
		if (min > num)min = num;
		if (max < num)max = num;
	}

	cout << "가장 작은 값 - " << min << ", 가장 큰 값 - " << max << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:43:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	cout << "최댓값 - " << *max_element(a.begin(), a.end()) << endl;		//역참조 operator
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:49:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto p = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *p.first << endl;
	cout << "최댓값 - " << *p.second << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:51:23 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto [최솟값의위치, 최댓값의위치] = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *최솟값의위치 << endl;
	cout << "최댓값 - " << *최댓값의위치 << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:20 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

//	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
//		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:19 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}]", id);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - ", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:16:54 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {:15}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:17:16 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:18:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:21:33 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	ofstream out{ "Dog 10만마리",ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog,sizeof(Dog));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:40:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
	friend ostream& operator<<(ostream& os,const Dog& dog) {
		cout << "id - " << dog.id << ", name - " << dog.name << endl;
	}
private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	Dog dog;
	int cnt{};
	while (in.read((char*)&dog, sizeof(Dog))) {
		++cnt;
	}

	cout << "읽은 객체 수 - " << cnt << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:48:40 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};

	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name <<" - "<< dog.id << endl;
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	cout << dogs.back() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 5:02:48 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};


	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name << " - " << dog.id;
	}

	friend istream& operator>>(ifstream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	//	[문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs)
	{
		in >> dog;				// operator>>(in,dog)
		cout << dog << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:18:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10];

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:19:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:24:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	throw 20250325;
	
	cout << "이 줄이 출력되면 되겠니?" << endl;		//throw로 예외 집어넣어서 처리를 해주지 않으면 사망
	delete[]p;
}

//---------
int main() 
//---------
{
	try{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:27:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	delete[]p;

	//	시간이 얼마쯤 흐른 후

	//	delete[]p; 얘를 한 번더 부르면 p가 뱅글링 ? 여하튼 프로그램 사망 
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:28:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	delete p;
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:29:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:34:31 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p{ new Dog };

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:38:27 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:39:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:41 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:42:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> p{ new Dog };		//	스택 언와이딩?
	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:44:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog>p=make_unique<Dog>();

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:40 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:48:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII : class로 자원을 관리하는 것, 클래스 생성할 때 자원을 연결 
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:02:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:03:11 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:04:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:10:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out},
		[](char c) {return toupper(c); });

	save("main.cpp");
}