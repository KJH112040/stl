// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::ofstream out{ "2025 1 STL 화56목78 강의저장.txt",std::ios::app };

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	/*
	char c;
	while (in >> c)			in>>c 고급I/O : in.operator>>(c)	, operator>>(in,c)
		out << c;
	*/
	char c;
	in >> std::noskipws;
	while (in >> c)
		out << c;

}


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::vector<char> v(size);
	std::copy(std::istreambuf_iterator{ in }, {}, v.begin());
	std::copy(v.begin(), v.end(), std::ostreambuf_iterator{ out });
}                  


// -----------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();	//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	using namespace std::chrono_literals;
	std::cout << now + 9h << std::endl;

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:03:14 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-06 오후 5:06:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 6일 목요일				(1주 2일)
//------------------------------------------------------------------------------------------------
//	컴파일 환경 확인 / 한 학기 강의를 저장할 save 만들기
//	과제 - save를 save.cpp로 분리하라.
//------------------------------------------------------------------------------------------------
//	VS 버젼 - 17.13 이상
//	Release / x64, C++ 언어 표준 - std::C++latest, SDL 검사 - 아니요
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view);
//	C++ 사용 x	
//	1. T[];	--->	array<T,N>
//	2. char*	---->	srting
// 	3. T*	--->	unique str...ㅠ 못 적음

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout <<"\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - " 
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구
	
	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:42:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//	[문제] save 함수를 제대로 코딩하라.
void save(std::string_view fileName);

//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 1:48:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	save 파일로 분리 / template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

//	[문제] save 기능을 파일로 분리하라


//---------
int main() 
//---------
{
	std::cout << "2025 STL" << std::endl;
	
	save("main.cpp");
	save("save.h");
	save("save.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.h													2025년 3월 11일
//----------------------------------------------------------------------------
#pragma once
void save(std::string_view);


=================================================
저장한 시간: 2025-03-11 오후 1:51:59 화요일
=================================================

//----------------------------------------------------------------------------
//	save.cpp												2025년 3월 11일
//
//	한 학기 강의를 덧붙여 저장하는 함수 입니다.
//----------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include<chrono>

//------------------------------
void save(std::string_view fileName)
//------------------------------
{
	//	fileName를 읽기모드로 연다	ifstream
	std::ifstream in{ fileName.data() };	//	RAII
	if (not in) {
		std::cout << fileName << "을 열 수 없습니다." << std::endl;
		exit(20250306);
	}

	//	쓰기 모드로 저장할 파일을 연다	ofstream
	std::string nameToSave{ "2025 1 STL 화56목78 강의저장.txt" };
	std::ofstream out{ nameToSave,std::ios::app };

	//	저장했다고 화면 출력한다.
	auto size = std::filesystem::file_size(fileName);
	std::cout << "\"" << nameToSave << "에 " << fileName << "을 덧붙였습니다. - "
		<< size << " bytes\"" << std::endl;

	//	저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now();			//	time_point를 얻는다 epoch:1970년 1월 1일 자정
	auto utc = std::chrono::system_clock::to_time_t(now);	//	UTC 시간으로 변경
	auto lt = std::localtime(&utc);							//	지역달력 시간으로
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n' << '\n';
	out << "=================================================" << '\n';
	out << "저장한 시간: " << std::put_time(lt, "%c %A") << '\n';
	out << "=================================================" << '\n';
	out << '\n';

	out.imbue(old);		//	원래 locale을 복구

	//	읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여 쓴다
	std::copy(std::istreambuf_iterator{ in }, {}, std::ostreambuf_iterator{ out });
}


=================================================
저장한 시간: 2025-03-11 오후 2:03:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
void change(int&, int&);

//---------
int main() 
//---------
{
	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:26:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

void change(int&, int&);
void change(Dog&, Dog&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

void change(int& a, int& b) {
	int t{a};
	a = b;
	b = t;
}

void change(Dog& a, Dog& b) {
	Dog t{ a };
	a = b;		// a.operator=(b)
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:36:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template<class T>
void change(T&, T&);

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}

template <class T>
void change(T& a, T& b) {
	T t{a};
	a = b;
	b = t;
}


=================================================
저장한 시간: 2025-03-11 오후 2:54:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	template 복습
//------------------------------------------------------------------------------------------------
// iostream standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _IOSTREAM_
#define _IOSTREAM_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR
#include <istream>
#include <ostream>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new
_STD_BEGIN
#ifdef _M_CEE_PURE
__PURE_APPDOMAIN_GLOBAL extern istream cin;
__PURE_APPDOMAIN_GLOBAL extern ostream cout;
__PURE_APPDOMAIN_GLOBAL extern ostream cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream clog;
__PURE_APPDOMAIN_GLOBAL extern istream* _Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern wistream wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream wclog;
__PURE_APPDOMAIN_GLOBAL extern wistream* _Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wclog;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream cin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream clog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream* _Ptr_cin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_clog;

_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream wcin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wclog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream* _Ptr_wcin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wclog;

#ifdef _CRTBLD // TRANSITION, ABI: _Winit appears to be unused
class _CRTIMP2_PURE_IMPORT _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;

private:
	__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;
};
#endif // defined(_CRTBLD)

#endif // ^^^ !defined(_M_CEE_PURE) ^^^
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _IOSTREAM_
#include "save.h"
using namespace std;			// 우리는 이렇게 하면 안된다.

//	[문제] C++ 언어에서 change 함수는 몇 번이나 overloading 해야 할까?
//	---> C++ 언어의 자료형은 몇 개인가? ---> 무한하다

class Dog {
public:
	Dog() {};
	Dog(int n) :num{ n } {};
	
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}

private:
	int num{};
};

template <class T>
void change(T& a, T& b) 
{
	T t{ a };
	a = b;
	b = t;
}

//---------
int main() 
//---------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		// 1. change(Dog, Dog);
		// 2. change(Dog&, Dog&);
		// 3. 컴파일러가 template을 이용하여 코드 생성
		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	{
		int a{ 1 }, b{ 2 };

		change(a, b);

		cout << a << ", " << b << endl;		// 의도 - 2, 1 이 출력되어야 한다
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:07:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		if (i % 100 == 0)cout << '\n';
		cout << uid(dre) << " ";
		cout << endl;
	}
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-11 오후 3:08:33 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 11일 화요일				(2주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라
default_random_engine dre;
uniform_int_distribution<int> uid{0,999'9999};

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:37:24 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{ random_device{}()};
uniform_int_distribution<int> uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	가장 큰 값을 찾아 화면에 출력하라

//---------
int main() 
//---------
{
	for (int i = 0; i < 1000; ++i) {
		print("{:8}", uid(dre));
	}
	cout << endl;
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 3:52:32 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	// T[N]
	int arr[1'000];
	for (int i = 0; i < 1000; ++i)
		arr[i] = uid(dre);
	
	int maxValue{ numeric_limits<int>::min() };
	
	for (int i = 0; i < 1000; ++i) {
		if (maxValue < arr[i])
			maxValue = arr[i];
	}
	
	cout << "최댓값 - " << maxValue << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:10:02 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	auto 위치 = max_element(arr.begin(), arr.end());
	
	cout << "최댓값 - " << *위치 << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:11:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 메모리에 저장하라
//	저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라		(5분)

//---------
int main() 
//---------
{
	array<int, 1'000> arr;				// T[N]	<< STL에서는 빵점처리... --------> array<T,N>

	for (int& num: arr)		// magic number, hard-wired : for-loop에 뭘 의미하는 지 모를 숫자를 적는,,,거,,, ex) i < 1'000
		num = uid(dre);
	
	cout << "최댓값 - " << *max_element(arr.begin(), arr.end()) << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:25:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:<8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:26:13 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<array>
#include<algorithm>
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	for (int i = 0; i < 1'000; ++i)
		print("{:^8}",uid(dre));
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:31:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8}",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:37:31 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	for (int i = 0; i < 1'000; ++i)
		print(out,"{:8} *** ",uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:40:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<print>		// C++ 23
#include<random>
#include "save.h"
using namespace std;

default_random_engine dre{};
uniform_int_distribution uid{ 0,999'9999 };

//	[문제] 랜덤 int 1000개를 파일"int 1000개.txt"에 텍스트 모드로 저장하라.
//	파일을 열었을 때 사람이 읽을 수 있어야 한다.
//	파일을 읽어 원래 int 값을 가져올 수 있어야 한다.

//---------
int main() 
//---------
{
	ofstream out{ "int 1000개.txt" };		// RAII
											// ios::text는 없음 text는 defalut임. 아무것도 안 하면 그게 text mode

	int count{};
	for (int i = 0; i < 1'000; ++i) {
		print(out, "{:8}", uid(dre));			// 아무것도 안 쓰면 cout에 쓰지만, 앞에 인자 적어주면 저 변수에다? 씀.
		if (not(++count % 10))
			out << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:52:06 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	int num, maxValue{numeric_limits<int>::min()};
	size_t cnt{ };

	while (in >> num) {
		++cnt;
		if (num > maxValue)
			maxValue = num;
	}
	cout << "읽은 개수 - " << cnt << endl;
	cout << "최댓값 - " << maxValue << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:58:46 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값 - "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 4:59:12 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지도 답지에 써라.	(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	cout<< "최댓값: "<< *max_element(istream_iterator<int>{in}, {})<<endl;
	// max_element는 위치를 알려주는데, *를 치면 그 위치에 있는 값을 알려줌.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-13 오후 5:10:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 13일 목요일				(2주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	파일에 저장하고 읽어 오기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;/*, cnt{0};
	while (in >> num) {
		in >> arr[cnt];
		++cnt;
	}*/
	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:35:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	랜덤 데이터를 생성하기
//							/	파일에 텍스트로 기록하기
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	random_device rd{};
	cout << "이 값은 추적 불가능" << endl;
	
	for (int i = 0; i < 100; ++i)
		cout << rd() << '\t';

	//ifstream in{ "int 1000개.txt" };
	//if (not in)
	//	return 20250313;

	//array<int, 1000> arr;
	//int num;/*, cnt{0};
	//while (in >> num) {
	//	in >> arr[cnt];
	//	++cnt;
	//}*/
	//for (int i = 0; i < 1000; ++i) {
	//	in >> num;
	//	arr[i] = num;
	//}

	//for (int num : arr)
	//	print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:36:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary io
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include<array>
#include<print>
#include<random>
#include "save.h"
using namespace std;

//	[문제] 파일 "int 1000개.txt"에는 int 값 1000개가 text로 기록되어 있다.
//	이 데이터를 메모리에 저장하라.
//	메모리에 있는 데이터를 화면에 출력하라.		(5분)

//---------
int main() 
//---------
{
	ifstream in{ "int 1000개.txt" };
	if (not in)
		return 20250313;

	array<int, 1000> arr;
	int num;

	for (int i = 0; i < 1000; ++i) {
		in >> num;
		arr[i] = num;
	}

	for (int num : arr)
		print("{:8}", num);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:45:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << "2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:46:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	cout << "16진수 - " << hex << num << endl;
	cout << "10진수 - " << num << endl;

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:47:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<bitset>
#include "save.h"
using namespace std;

//	[문제] 지난 시간에 int 1000개를 파일에 기록하였다.
//	int 1000개를 저장하기 위해 얼마만큼의 파일 바이트를 사용하였나? -> 8200 바이트

//---------
int main() 
//---------
{
	int num{ 0x01'02'03'04 };

	bitset<32>binary = num ;

	cout << " 2진수 - " << binary << endl;
	cout << "10진수 - " << num << endl;
	cout << "16진수 - " << hex << num << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:55:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:56:30 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a{};

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:57:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	a.fill(333);

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 1:59:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	int i{};
	for (int& num : a)
		num = ++i;

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:00:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:01:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include "save.h"
using namespace std;

//	[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 있다.
//	-> 저수준 입출력 함수를 사용한다.

//---------
int main() 
//---------
{
	array<int, 1000> a;
	
	iota( a.begin(),a.end(),1234 );

	for (int num : a)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:12:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:14:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int)*a.size());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:17:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );

	cout << "a에 들어있는 int 개수 - " << a.size() << endl;
	// 기록 했을 때 메모리를 하나 더 잡아서? -> a의 int개수(size)는 그대로임.
	// 마지막 EOF는 파일 사이즈에 영향을 미치지 않음.

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로",ios::binary };			// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:20:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//------------------------------------------------------------------------------------------------
//	오늘 공부한 내용을 데이터를 바꿔 스스로 복습해보자
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<numeric>
#include<fstream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 1000> a;
	iota( a.begin(),a.end(),1234 );
	a.fill(0x0a0a0a0a);

	//	[문제] a의 data를 파일 "int 1000개 메모리 그대로"에 기록하자
	ofstream out{ "int 1000개 메모리 그대로"};	
	// 이 파일을 텍스트 모드로 연 것임. 그럼 왜 binary로 열면 괜찮아질까?
	// 텍스트 모드는 인간이 눈으로 보는 걸 전제로 함. -> 보기 편하게 하기 위한 작업을 os가 해줌. (windows,unix?,Linux...)
	// windows가 치는 장난?
	
	out.write((char*)a.data(), sizeof(int)*a.size());	// 얘는 정직함. 어디에서 잘못되었을까?

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:35:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<random>
#include "save.h"
using namespace std;

//	파일 "int 10만개를 바이너리모드 write함수로 기록" 에 10만개의 랜덤 int 값을 기록하자.
//	이 int값은 메모리 크기 그대로 기록되어 있다.
//	파일을 binary mode로 열자

default_random_engine dre;	// 5천 바이트 짜리임,,

//---------
int main() 
//---------
{
	ofstream out{ "int 10만개를 바이너리모드 write함수로 기록" , ios::binary };
	
	uniform_int_distribution uid{ numeric_limits<int>::min(), numeric_limits<int>::max() };

	int num;
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write((char*)&num, sizeof(int));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 2:59:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:00:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:36 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:02:57 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:03:02 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	binary I/O
//					->	파일을 binary모드로 열어야 변환이 일어나지 않는다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary로 열어 기록한 파일 "int 10만개를 바이너리모드 write함수로 기록"에는
//	int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 write 함수를 사용)
//	int값 10만개를 읽어서 메모리에 저장하라.
//	가장 작은 값을 찾아 화면에 출력하라.
//	이 문제를 해결하는 코드를 답지에 적어라
//	화면에 출력된 값도 답지에 적어라

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록"};
	if (not in)
		return 20250318;

	array<int, 10'0000>a;
	in.read((char*)a.data(), sizeof(int) * a.size());
	
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;
	// binary로 열 때:-2147431498,	text로 열 때:-2024079360 이거 값 바뀜;;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-18 오후 3:09:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 18일 화요일				(3주 1일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() {
		// 다음 시간에 만들어 보겠습니다.
	}
private:
	string name;		// 32
	size_t id;			// 8
};

//	Dog 만마리를 생성하여 파일에 저장(write). 메모리로 읽어와서 처리(정렬).

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:39:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	int min{ a[0]}, max{0};

	for (int num : a) {
		if (min > num)min = num;
		if (max < num)max = num;
	}

	cout << "가장 작은 값 - " << min << ", 가장 큰 값 - " << max << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:43:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	cout << "최댓값 - " << *max_element(a.begin(), a.end()) << endl;		//역참조 operator
	cout << "최솟값 - " << *min_element(a.begin(), a.end()) << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:49:29 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 int 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto p = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *p.first << endl;
	cout << "최댓값 - " << *p.second << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 3:51:23 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] binary mode로 열어 write 함수로 iint 10만개를 기록한
//	파일 "int 10만개를 바이너리모드 write함수로 기록"이 있다.
//	읽어서 메모리에 모두 저장하라.
//	메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//	출력된 값을 답지에도 적어라.

//---------
int main() 
//---------
{
	ifstream in{ "int 10만개를 바이너리모드 write함수로 기록",ios::binary };

	array<int, 10'0000>a;
	in.read((char*)a.data(), a.size() * sizeof(int));

	auto [최솟값의위치, 최댓값의위치] = minmax_element(a.begin(), a.end());
	cout << "최솟값 - " << *최솟값의위치 << endl;
	cout << "최댓값 - " << *최댓값의위치 << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:20 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

//	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:14:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
//		println("[{:7}] - { }", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:19 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}]", id);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:15:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - ", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:16:54 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {:15}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:17:16 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	Dog dog;

	dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:18:38 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:21:33 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<random>
#include<print>
#include<fstream>
#include "save.h"
using namespace std;

//	[문제] class Dog 객체 10만개를 binary mode로 연 파일 "Dog 10만마리"에 저장하였다.
//	객체 크기 그대로 write 함수를 사용하여 저장하였다.

default_random_engine dre;
uniform_int_distribution<int> uid{'a','z'};

class Dog {
public:
	Dog() {				// name(15글자고정, 임의의 소문자)과 id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i)
			name += uid(dre);
	}

	void show() const{
		println("[{:7}] - {}", id, name);		// { } <<이렇게 하면 안됨. {} <<이렇게 붙이거나 해야함.
	}

private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

int Dog::sid{};


//---------
int main() 
//---------
{
	ofstream out{ "Dog 10만마리",ios::binary };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write((char*)&dog,sizeof(Dog));
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:40:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
	friend ostream& operator<<(ostream& os,const Dog& dog) {
		cout << "id - " << dog.id << ", name - " << dog.name << endl;
	}
private:
	string name;
	int id{};

	static int sid;			// scope - local, life time - global
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	Dog dog;
	int cnt{};
	while (in.read((char*)&dog, sizeof(Dog))) {
		++cnt;
	}

	cout << "읽은 객체 수 - " << cnt << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 4:48:40 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};

	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name <<" - "<< dog.id << endl;
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
//	Dog 객체 10만개를 메모리에 저장하라.
//	가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라.	(10분)

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	cout << dogs.back() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-20 오후 5:02:48 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 20일 목요일				(3주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료를 처리하기	-	Dog를 읽고 쓴다. read/write
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include "save.h"
using namespace std;

class Dog {
private:			// 접근 지시자
	string name;
	int id{};


	friend ostream& operator<<(ostream& os, const Dog& dog) {			// friend는 우선순위가 최하위?
		return os << dog.name << " - " << dog.id;
	}

	friend istream& operator>>(ifstream& is, const Dog& dog) {
		return is.read((char*)&dog, sizeof(Dog));
	}
};

//	[문제] e-classㅔ서 다운 받은 파일 "Dog 10만마리"는 binary 모드로 열었고,
//	위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 10만마리",ios::binary };
	if (!in)
		return 20250320;

	//	[문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs)
	{
		in >> dog;				// operator>>(in,dog)
		cout << dog << endl;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:18:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10];

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:19:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "free-store의 메모리 - " << p << endl;
	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;
	
	delete[]p;
}

//---------
int main() 
//---------
{
	for (int i=0;i<10;++i)
		f();
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:24:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	throw 20250325;
	
	cout << "이 줄이 출력되면 되겠니?" << endl;		//throw로 예외 집어넣어서 처리를 해주지 않으면 사망
	delete[]p;
}

//---------
int main() 
//---------
{
	try{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:27:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

void f()
{
	int* p = new int[10] {};

	cout << "합계 - " << accumulate(p, p + 10, 0) << endl;

	delete[]p;

	//	시간이 얼마쯤 흐른 후

	//	delete[]p; 얘를 한 번더 부르면 p가 댕글링 ? 여하튼 프로그램 사망 
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:28:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	delete p;
}

//---------
int main() 
//---------
{
	f();
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:29:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:34:31 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p{ new Dog };

	throw 1;

	delete p;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:38:27 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:39:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) :p{p} {

	}
	~스마트() {
		delete p;
	}
};

void f()
{
	스마트 p{ new Dog };

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {

	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:41:41 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> { new Dog };		//	스택 언와이딩?

	throw 1;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:42:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> p{ new Dog };		//	스택 언와이딩?
	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:44:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog>p=make_unique<Dog>();

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:45:40 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 2:48:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	동적할당과 smart pointer - RAII : class로 자원을 관리하는 것, 클래스 생성할 때 자원을 연결 
//	- C++ stack-unwinding을 보장한다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<numeric>
#include<memory>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	unique_ptr<Dog[]>p = make_unique<Dog[]>(10);

	throw 20250325;

	cout << "이 줄이 출력될 수 없다." << endl;
}

//---------
int main() 
//---------
{
	try
	{
		f();
	}
	catch (...) {
		cout << "예외를 잡아 처리하였다" << endl;
	}
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:02:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:03:11 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		if (islower(c))
			c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:04:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	char c;
	in >> noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-25 오후 3:10:14 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 25일 화요일				(4주 1일)
//------------------------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out},
		[](char c) {return toupper(c); });

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:28:00 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	많은 수의 자료 - FILE
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] "메인.cpp"의 내용 중에 소문자를 모두 대문자로 바꿔 "메인 대문자.cpp"에 저장하라

//---------
int main() 
//---------
{
	ifstream in{ "main.cpp" };
	if (!in)
		return 20250325;

	ofstream out{ "메인 대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out},
		[](char c) {return toupper(c); });

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:32:22 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:54:26 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	array<int, 1'000'00> a;

	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//q
	(&a, a.size(), sizeof(int), [](int a, int b){})

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a | ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 3:55:12 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	array<int, 1'000'00> a;

	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//qsort(&a, a.size(), sizeof(int), [](int a, int b){})

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(5)
					| views::take(1)
		)
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:12:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	//	바꿔야 하면 1
	//	이미 정렬상태이면 -1
	//	둘이 정렬기준상 동일한 값이라면 0
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	//qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:17:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:17:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 오름차순 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 오름차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(3000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:21:19 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(), sizeof(array<int,1'000'0000>::value_type), 내림차순);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:34:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	

	int(*정렬기준)(const void*, const void*) = 오름차순;			//	함수 포인터
	//	정렬기준 = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:41:01 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	qsort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

int 오름차순(const void* a, const void* b) {
	int* p = (int*)a;				//	C언어 스타일, 단순무식?
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	else return 0;

	//const int* p = (const int*)a;	//	맘대로 변환가능하기 때문에 void*? 
	//int* pp = (int*)p;
}

int 내림차순(const void* a, const void* b) {
	return *(int*)b - *(int*)a;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	

	//int(*정렬기준)(const void*, const void*) = 오름차순;			//	함수 포인터
	int(*정렬기준)(const void*, const void*) = 내림차순;
	qsort(a.data(), a.size(), sizeof(int), 정렬기준);

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	//	원래는 save->("main.cpp") 이런 식으로 인자전달해야 하나 번거로워서? 약식 제공
	(*save)("main.cpp");		//	save라는 코드의 시작번지가 save임 사실 함수는 (*save)이고 이게 정식 코드
}


=================================================
저장한 시간: 2025-03-27 오후 4:46:43 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬
	sort(a.begin(), a.end());
	
	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:54:39 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬
	sort(a.begin(), a.end(), 오름차순);		//	default 정렬 operator <
	
	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000))
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:58:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 4:58:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:00:55 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::microseconds>(끝 - 시작) << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:01:21 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	for (int &num : a)
		num = uid(dre);
	
	//	정렬에 걸리는 시간 측정
	auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
	sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

	cout << "경과시간(duration) - " << 끝 - 시작 << endl;
	cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:04:35 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-03-27 오후 5:10:07 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution<int> uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort<array<int,1'000'0000>::iterator>(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	//for (int num:a	| ranges::views::take(1000))
	//	print("{:8}", num);
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:26:04 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	3월 27일 목요일				(4주 2일)
//------------------------------------------------------------------------------------------------
//	4월 24일 (8주 2일차) - 중간고사
//	RAII : 자원의 생명주기를 객체의 생명주기에 동기화
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include "save.h"
using namespace std;

//	[문제] 랜덤 int 1000만 개를 메모리에 저장하자.
//	랜덤 int 값은 [ 0, 1'000'0000 ) ==> 0부터 999'9999까지 값을 갖도록
//	C++언어의 sort를 사용하여 오름차순으로 정렬하라.
//	정렬한 결과를 앞에서부터 1000개만 화면에 출력하라.

array<int, 1'000'0000> a;

default_random_engine dre;
uniform_int_distribution<int> uid{ 0,999'9999 };

bool 오름차순(const int a, const int b) {
	return a < b;
}

//---------
int main() 
//---------
{
	{
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort<array<int,1'000'0000>::iterator>(a.begin(), a.end(), 오름차순);					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	{	// 내림차순으로 정렬
		for (int& num : a)
			num = uid(dre);

		//	정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();	//	스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {return a > b; });					//	default 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();		//	스톱워치 끝

		cout << "경과시간(ms) - " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	}

	//	앞에서 부터 1000개를 화면 출력
	for (int num:a	| ranges::views::take(1000)|views::reverse)
		print("{:8}", num);
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:34:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?

	[]() {
		cout << "안녕! 난 이름이 없어." << endl;
	}();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:37:29 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?

	cout<< "람다의 정체 - "<<typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:39:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?
	//	람다의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>

	cout<< "람다 1의 정체 - "<<typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;

	cout << "람다 2의 정체 - " << typeid([]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}).name() << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:46:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	//	람다는 도대체 무엇인가?
	//	람다의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>
	//	람다 1의 정체 - class `int __cdecl main(void)'::`2'::<lambda_1>
	//	람다 2의 정체 - class `int __cdecl main(void)'::`2'::<lambda_2>

	[]() {
		cout << "안녕! 난 이름이 없어." << endl;
		}();

	int* 저장 = (int*)save;
	cout <<"save함수가 저장된 메모리의 번지 - "
		<< 저장 << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:50:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {		// 함수 호출 연산자
		cout << "나를 왜 불렀죠?" << endl;
	}
};

//---------
int main() 
//---------
{
	Dog dog;

	dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:52:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
public:
	void operator()() {		// 함수 호출 연산자
		cout << "나를 왜 불렀죠?" << endl;
	}
};

//---------
int main() 
//---------
{
	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;

	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:53:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다
//	4.
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	class Dog {
	public:
		void operator()() {		// 함수 호출 연산자
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;
	//	class Dog가 전역일 때 : class Dog


	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 1:54:55 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	class Dog {
	public:
		void operator()() {		// 함수 호출 연산자
			cout << "나를 왜 불렀죠?" << endl;
		}
	};

	Dog dog;//<---- 람다

	cout << typeid(dog).name() << endl;
	//	class Dog가 전역일 때 : class Dog
	//	class Dog가 지역일 때 : class `int __cdecl main(void)'::`2'::Dog


	dog.operator()();		// dog();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:14:21 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	class Dog {
	public:
		bool operator()(int a, int b)const {
			return a > b;
		}
	};
	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num<<' ';
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:14:40 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.
	auto Dog = [](int a, int b) -> bool {return a > b; };

	sort(a.begin(), a.end(), Dog);

	for (int num : a)
		cout << num << " ";
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:19:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라.

	class Dog {
	public:	
		bool operator()(int a, int b){return a > b; };
	};

	sort(a.begin(), a.end(), Dog{});

	for (int num : a)
		cout << num << " ";
	cout << endl;		//	10 9 8 7 6 5 4 3 2 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:22:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:27:17 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	-	4월 24일(8주 2일) 목요일
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;
	// false

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:31:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	오늘의 주제 : Callable =====> 무한 가지 타입이 있음.
//	A Callable type is a type for which the INVOKE and INVOKE<R> operations 
// (used by, e.g., std::function, std::bind, and std::thread::thread) are applicable.
//	=> Callable type - 호출가능한 타입	--------> 모든 것을 대표하는 function
//	1. 함수
//	2. 함수 포인터
//	3. 람다 - 이름없는 함수 - 실체가 있어야 한다. (VS class로 코딩)
//	4. 함수 객체(function object) - 함수호출연산자를 오버로딩한 클래스 객체
//	5. 멤버함수 (객체에 점찍어서 호출하는 함수)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<functional>
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	auto p = [](int a, int b) {return a > b; };
	cout << boolalpha << p(3, 4) << endl;


	function<bool(int,int)> 내림차순 = p;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:39:09 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//---------
int main() 
//---------
{
	array<Dog, 10>dogs;

	for (const Dog& dog : dogs)
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:39:45 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}

private:
	string name;
	int id;
};

//---------
int main() 
//---------
{
	array<Dog, 10>dogs;

	for (const Dog& dog : dogs)
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-01 오후 2:47:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 1일 화요일				(5주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include<print>
#include<array>
#include<fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{};

class Dog {
public:
	Dog() {
		//	cout << "설마 생성자가?" << endl;
		int len = uidNameLen(dre);
		for (int i = 0; i < len; ++i)
			name += uidName(dre);
		id = uidId(dre);
	}

	void show() const {
		println("{:12} - {}", id, name);
	}


private:
	string name;
	int id;

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

//	[문제] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//
//	ofstream out{ "Dog 십만마리" };
//
//	Dog dog;
//	out << dog;
//	ostream& operator<<(ostream&os,const Dog&og){
//		return os << dog.id << " " << dog.name << " ";
//	}

//---------
int main() 
//---------
{
	ofstream out{ "Dog 십만마리" };

	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out << dog;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:39:21 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
//#include<algorithm>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	int name_len() {
		return sizeof(name);
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	int num;
	string name;
	int cnt{};
	while (in >> num >> name) {
		println("[{:7}] - {:12} {}", ++cnt, num, name);
	}

	//in.read((char*)dogs.data(), dogs.size() * sizeof(Dog));

	//cout << "마지막 객체의 정보 -" << dogs[9'9999] << endl;

	//sort(dogs.begin(), dogs.end(), [](Dog a, Dog b) {return a.name_len() < b.name_len(); });

	//for (int i = 0; i < 1000; ++i)
	//	cout << dogs[i] << " ";
	//cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:46:39 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
//#include<algorithm>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:58:05 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::take(1000))		// 코딩 겉멋이 들었다면 auto를 쓸텐데, 여기선 auto를 쓰더라도 const auto&로 써야함.
		dog.show();										// auto 쓸 때 없는 데에 쓰지 말라는 듯

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 3:59:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}
	size_t getNameLen() const {
		return name.length();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end(), [](const Dog& dog1, const Dog& dog2) {
		return dog1.getNameLen() < dog2.getNameLen();
	});

	for (const Dog& dog : dogs | views::reverse)		// 내림차로 출력해보기
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 4:06:25 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	Callable
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<fstream>
#include<array>
#include<string>
#include<print>
#include<algorithm>
#include<ranges>
#include "save.h"
using namespace std;

//	[설명] Dog 10만 마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
//	파일은 다음 코드로 열었다.
//		ofstream out{ "Dog 십만마리" };
//
//	Dog 객체는 class Dog의 friend operator<<를 사용하여 저장하였다.
//
//	[문제] 파일"Dog 십만마리"에는 정확하게 10만 개의 Dog 객체가 저장되어 있다.
//	파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
//	제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
//	메모리에 저장된 Dog 객체를 멤버 name 길이 기준 오름차순으로 정렬하라.
//	정렬된 Dog 객체를 앞에서 부터 1000개를 화면에 출력하라.

class Dog {
public:
	void show() const {
		println("[{:12}] - {}", id, name);
	}

	bool operator<(const Dog& other) {
		return name.size() < other.name.size();
	}
private:
	string name;
	int id;
	
	friend ostream& operator<<(ostream& os, Dog dog) {
		return os << dog.id << " " << dog.name << " ";
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		return is >> dog.id >> dog.name;
	}
};

array<Dog, 10'0000> dogs;

//---------
int main() 
//---------
{
	ifstream in{ "Dog 십만마리" };
	if (not in) {
		cout << "Dog 십만마리 - 파일을 불러올 수 없습니다." << endl;
		return 20250403;
	}

	for (int i = 0; i < 10'0000; ++i)
		in >> dogs[i];

	cout << "제일 마지막 객체의 정보 - ";
	dogs.back().show();
	// 마지막 객체 : [  1970393199] - etpyzzulctbtq

	cout << "Dog name 길이 기준으로 오름차순(ascending order)으로 정렬합니다" << endl;
	sort(dogs.begin(), dogs.end());
	//	dogs.begin(), dogs.end() - 정렬할 데이터의 범위

	for (const Dog& dog : dogs | views::reverse)		// 내림차로 출력해보기
		dog.show();

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 4:37:58 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

class STRING {

};

//---------
int main() 
//---------
{
	string s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-03 오후 5:10:47 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 3일 목요일				(5주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) - 4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include "save.h"
using namespace std;

// public, private, protected ---> acssess modifiy모디파이?
class STRING {
public:
	STRING(const char* s) :len{strlen(s)} {		// [] (array) -> *(pointer)로 collapsing 
		// p = new char[len];	-> unique_ptr이기에 불가능한 작업, unique_ptr은 자원을 독점하는 놈
		p.reset();
		p = make_unique<char[]>(len);		// Lvalue : 현대식으로는 location value (left value아님...)
		memcpy(p.get(), s, len);					// DMA : Direct Memory Acssess
	};

	size_t size() const {
		return len;
	}
private:
	size_t len{};
	unique_ptr<char[]> p{};

	friend ostream& operator<<(ostream & os, const STRING& str) {
		for (int i = 0; i < str.len; ++i)
			os << str.p[i];
		return os;
	}
};

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	//	27
	//	std::string과 유사한 클래스

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	//STRING t;
	//t = s;

	//STRING u = s;

	//cout << t << endl;
	//cout << s << endl;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING(const char* s);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);
};


=================================================
저장한 시간: 2025-04-08 오후 1:44:42 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"STRING.h"

STRING::STRING(const char* s) :len{ strlen(s) } 
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);
};

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}


=================================================
저장한 시간: 2025-04-08 오후 2:52:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	//STRING s{ "std::string과 유사한 클래스" };

	//cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	//cout << s << endl;

	//string t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	//t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	//string u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	//cout << t << endl;
	//cout << u << endl;

	STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:54:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	//STRING s{ "std::string과 유사한 클래스" };

	//cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	//cout << s << endl;

	//string t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	//t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	//string u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	//cout << t << endl;
	//cout << u << endl;

	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

//STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	STRING s{ "std::string과 유사한 클래스" };

	cout << s.size() << endl;		// s가 확보한 자원의 바이트 수

	cout << s << endl;

	STRING t;		// default 생성자는 special 멤버라서 안 만들어 줌. 
	t = s;			// operator는 special 함수?멤버? 여하튼 자동 생성해줘야 하는데 안 해주고 있음. 아마?

	STRING u = s;		// s를 원본으로 u 복사 생성하는 동작, 얘도 special 함수

	cout << t << endl;
	cout << u << endl;

	//cout << "메인 시작" << endl;
	//STRING t = s;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{
	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 2:56:17 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
static bool 관찰{ true };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 2:57:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰 = false;			// 관찰하고 싶으면 true로 설정

STRING s{ "이제 준비가 끝났다" };

//---------
int main() 
//---------
{

	cout << "메인 시작" << endl;
	STRING t = s;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:07:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	//관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() > b.size();
	});

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:08:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	//관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:08:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});
	관찰 = false;

	//관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	//관찰 = false;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;

//---------
int main() 
//---------
{
	관찰 = false;

	array<STRING, 5> a{ "1","333","22","55555","4444" };

	//	길이 기준 오름차순 정렬하고 출력하라
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& a, const STRING& b) {
		return a.size() < b.size();
	});
	관찰 = false;

	관찰 = true;
	for (const STRING& str : a) {
		cout << str << endl;
	}
	관찰 = false;

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 3:09:47 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ true };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-08 오후 3:11:07 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-08 오후 3:12:32 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 8일 화요일				(6주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	과제		(30) -	4월 10일 설명
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 내부 동작을 관찰할 수 있게 하자.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << s << endl;
	cout << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:51:08 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	string s{ "표준 string" };
	string t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:52:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	//	다음 시간에는 STRING도 이렇게 동작하게 하자
	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:53:31 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;

	save("main.cpp");
	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 3:55:08 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880

	cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	//save("STRING.h");
	//save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	
	// 이동의미?법  move simentic? 무브 시멘틱

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:24:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900
	//[2] 복사생성자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	
	// move semantic

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//s - 표준 string
	//t - 표준 string

	save("main.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1048 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f660, 자원메모리 : 0x202546f2880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0x4c6d90f630, 자원메모리 : 0x202546f2900

	save("STRING.h");
	save("STRING.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:25:10 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	관찰 = true;

	STRING s{ "표준 string" };
	STRING t = move(s);
	//[1] 생성자(char*), 자원수:11, 메모리 : 0xb52d31fb90, 자원메모리 : 0x26901493880
	//[2] 이동생성자, 자원수 : 11, 메모리 : 0xb52d31fba8, 자원메모리 : 0x26901493880
		
	// move semantic

	//cout << "s - " << s << endl;
	cout << "t - " << t << endl;
	//t - 표준 string

	save("main.cpp");
	save("STRING.h");
	save("STRING.cpp");
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1516 bytes"
	//"2025 1 STL 화56목78 강의저장.txt에 STRING.h을 덧붙였습니다. - 1115 bytes"
	//"2025 1 STL 화56목78 강의저장.txt에 STRING.cpp을 덧붙였습니다. - 2950 bytes"

	//[2] 소멸자, 자원수 : 11, 메모리 : 0xb52d31fba8, 자원메모리 : 0x26901493880
	//[1] 소멸자, 자원수 : 11, 메모리 : 0xb52d31fb90, 자원메모리 : 0x0
}


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-10 오후 4:42:18 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.get());
	other.p.release();

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-10 오후 4:46:13 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬

	// 출력
	관찰 = true;
	for (const STRING& str:a)
		cout << str << endl;
	관찰 = false;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:00:49 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});

	// 출력
	관찰 = true;
	for (const STRING& str:a)
		cout << str << endl;
	관찰 = false;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:01:34 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});
	관찰 = false;

	// 출력
	for (const STRING& str : a)
		cout << str << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-10 오후 5:04:18 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 10일 목요일				(6주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STRING - std::string과 유사한 클래스, STL 표준 컨테이너가 되도록..
//			 STL 표준 컨테이너가 되려면 여러 자격 요견 필요
//			 내부 동작을 관찰할 수 있게 하자. -> 가장 중요한 벡터를 이해할 수 있도록
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로

//---------
int main() 
//---------
{
	array<STRING, 5> a{ "1","333","55555","22","4444"};

	// 정렬
	관찰 = true;
	sort(a.begin(), a.end(), [](const STRING& lhs, const STRING& rhs) {
		return lhs.size() < rhs.size();
	});
	관찰 = false;
	//	[6] 이동생성자,		자원수 : 3,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2480
	//	[2] 이동할당연산자,	자원수 : 3,	메모리 : 0x1574cffb38, 자원메모리 : 0x1c6a6ab2480
	//	[6] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[7] 이동생성자,		자원수 : 5,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2450
	//	[3] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb50, 자원메모리 : 0x1c6a6ab2450
	//	[7] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[8] 이동생성자,		자원수 : 2,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab25d0
	//	[4] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb68, 자원메모리 : 0x1c6a6ab2450
	//	[3] 이동할당연산자,	자원수 : 3,	메모리 : 0x1574cffb50, 자원메모리 : 0x1c6a6ab2480
	//	[2] 이동할당연산자,	자원수 : 2,	메모리 : 0x1574cffb38, 자원메모리 : 0x1c6a6ab25d0
	//	[8] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0
	//	[9] 이동생성자,		자원수 : 4,	메모리 : 0x1574cffaa0, 자원메모리 : 0x1c6a6ab2580
	//	[5] 이동할당연산자,	자원수 : 5,	메모리 : 0x1574cffb80, 자원메모리 : 0x1c6a6ab2450
	//	[4] 이동할당연산자,	자원수 : 4,	메모리 : 0x1574cffb68, 자원메모리 : 0x1c6a6ab2580
	//	[9] 소멸자,			자원수 : 0,	메모리 : 0x1574cffaa0, 자원메모리 : 0x0

	// 출력
	for (const STRING& str : a)
		cout << str << endl;
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:17:59 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v;
	vector<vector<string>> vv;
	vector<vector<vector<int>>> vvv;		// 이렇게 까지 코딩하진 않음.

	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:25:46 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:26:44 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl; // value 타입 - int

	cout << "빈 array니?" << boolalpha << a.empty() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:30:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 0> a;			// 원소가 하나도 없는 array를 만든다면, 
								// There is a special case for a zero-length array (N == 0).
								// In that case, array.begin() == array.end(), which is some unique value.

	cout << "value 타입 - " << typeid(array<int, 0>::value_type).name() << endl; // value 타입 - int

	cout << "빈 array니? - " << boolalpha << a.empty() << endl;			// 빈 array니? - true

	array<int, 5> aa{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << aa[i] << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:36:01 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 5> a{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << a[i] << endl;			//	930484408
										//	32759
										//	1109086144
										//	32766
										//	1109086144
										//	32766
										//	0
										//	0
										//	0
										//	0
										//	1
										//	2
										//	3
										//	4
										//	5
										//	0
										//	0
										//	0
										//	- 1484893439
										//	59818
	cout << "몇 번째? - ";

	START:

	int num;
	cin >> num;

	try {
		a.at(num);
	}
	catch (std::exception& e) {
		cout << e.what() << endl;
		cout << "다시 입력해" << endl;
		goto START;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:36:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	array<int, 5> a{ 1,2,3,4,5 };		// int a[5] - structure로 포장 + 부가 기능
										// int a[5]를 쓰지 않는 이유 : 해킹에 취약?

	for (int i = -10; i < 10; ++i)
		cout << a[i] << endl;			//	930484408
										//	32759
										//	1109086144
										//	32766
										//	1109086144
										//	32766
										//	0
										//	0
										//	0
										//	0
										//	1
										//	2
										//	3
										//	4
										//	5
										//	0
										//	0
										//	0
										//	- 1484893439
										//	59818
	cout << "몇 번째? - ";				// 입력: 3 -> 종료, 입력: 100 -> "다시 입력해" 후 START로 돌아감.

	START:

	int num;
	cin >> num;

	try {
		a.at(num);
	}
	catch (std::exception& e) {
		cout << e.what() << endl;
		cout << "다시 입력해" << endl;
		goto START;
	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:40:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{1,2,3};			// {} - initializer-list

	for (int num : {1, 2, 3, 4, 5})
		cout << num << endl;

	//1
	//2
	//3
	//4
	//5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:43:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{1,2,3};			// {} - initializer-list
	// vector<int> v(100); 와 위 v는 다름.

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof v << endl;
	cout << "v의 주소 - " << addressof(v) << endl;
	cout << "v의 타입 - " << typeid(v).name() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:46:11 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> *p = new vector<int>{ 1,2,3 };			// {} - initializer-list

	// vector<int> v(100); 와 위 v는 다름.

	// v의 정체를 밝혀보세요.
	cout << "v의 크기 - " << sizeof *p << endl;
	cout << "v의 주소 - " << addressof(*p) << endl;
	cout << "v의 타입 - " << typeid(*p).name() << endl;
	//	v의 크기 - 24
	//	v의 주소 - 0000005217D3FA40
	//	v의 타입 - class std::vector<int, class std::allocator<int> >

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 2:55:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (vector<int>::iterator i = v.begin(); i != v.end(); ++i)
		cout << *i << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:03:09 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (auto i = v.cbegin(); i != v.cend(); ++i)
		cout << *i << endl;
	//	1
	//	2
	//	3

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:03:54 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

vector<int> v{ 1,2,3 };			// {} - initializer-list

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3 };			// {} - initializer-list

	// 반복자를 사용하여 access
	for (auto i = v.crbegin(); i != v.crend(); ++i)
		cout << *i << endl;
	//	3
	//	2
	//	1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-15 오후 3:12:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78	4월 15일 화요일				(7주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<numeric>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	키보드에서 입력한 정수값의 합계와 평균을 출력하라.

//---------
int main() 
//---------
{
	cout << "정수를 마음껏 입력하세요. ";
	vector<int> v{ istream_iterator<int>{cin}, {} };

	long long sum = accumulate(v.begin(), v.end(), 0LL);		// 0(zero) long long
	cout << "합계 - " << sum <<endl;
	cout << "평균 - " << (double)sum / v.size() << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 3:42:01 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	키보드에서 입력한 단어를 오름차순 정렬한 후 출력하라.	ctrl + z : 입력 종료 키

//---------
int main() 
//---------
{
	vector<std::string> v{ istream_iterator<string>{cin},{} };		// 키보드 입력 시작/끝

	sort(v.begin(), v.end());			// (시험 문제로 나올 수 있음)sort가 왜 정렬되는지? 클래스 애들은 어떻게 정렬하는지???

	for (const std::string& str : v)
		cout << str << endl;

	//	동해물과 백두산이 마르고 닳도록 하느님잉 보우하사 우리나라 만세
	//	무궁화 삼천리 화려강산 대한 사람 대한으로 긱ㄹ이 보전하세
	//	남산 위에 저 소나무 철갑을
	//	^ Z
	//	긱ㄹ이
	//	남산
	//	닳도록
	//	대한
	//	대한으로
	//	동해물과
	//	마르고
	//	만세
	//	무궁화
	//	백두산이
	//	보우하사
	//	보전하세
	//	사람
	//	삼천리
	//	소나무
	//	우리나라
	//	위에
	//	저
	//	철갑을
	//	하느님잉
	//	화려강산

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 3:53:15 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?

//---------
int main() 
//---------
{
	vector<int> v;

	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량 - " << v.capacity() << endl;
	cout << "메모리 - " << v.data() << endl;

	v.push_back(1);
	cout << "원소를 한 개 추가한 후 v의 내용" << endl;
	cout << "원소 개수 - " << v.size() << endl;
	cout << "용량 - " << v.capacity() << endl;
	cout << "메모리 - " << v.data() << endl;

	//	원소 개수 - 0
	//	용량 - 0
	//	메모리 - 0000000000000000
	//	원소를 한 개 추가한 후 v의 내용
	//	원소 개수 - 1
	//	용량 - 1
	//	메모리 - 000001FAB1552200
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:04:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?

//---------
int main() 
//---------
{
	vector<int> v;

	for (int i = 0; i < 10;++i) {
		cout << "--------------------------------------" << endl;
		cout << "원소 개수 - " << v.size() << endl;
		cout << "용량 - " << v.capacity() << endl;
		cout << "메모리 - " << v.data() << endl;

		v.push_back(1);
		cout << endl;
	}

	//--------------------------------------
	//	원소 개수 - 0
	//	용량 - 0
	//	메모리 - 0000000000000000
	//	--------------------------------------
	//	원소 개수 - 1
	//	용량 - 1
	//	메모리 - 000001D8614A24F0				// 새로운 메모리가 reallocation?
	//	--------------------------------------
	//	원소 개수 - 2
	//	용량 - 2
	//	메모리 - 000001D8614A2490
	//	--------------------------------------
	//	원소 개수 - 3
	//	용량 - 3
	//	메모리 - 000001D8614A2890
	//	--------------------------------------
	//	원소 개수 - 4
	//	용량 - 4
	//	메모리 - 000001D8614A29B0
	//	--------------------------------------
	//	원소 개수 - 5
	//	용량 - 6
	//	메모리 - 000001D8614A2D70				// 여기서부터 원소 개수 6까지는 메모리 주소가 변하지 않음 : 용량이 여유가 있어서
	//	--------------------------------------
	//	원소 개수 - 6
	//	용량 - 6
	//	메모리 - 000001D8614A2D70
	//	--------------------------------------
	//	원소 개수 - 7
	//	용량 - 9
	//	메모리 - 000001D86149F400				// 여기서 다시 한 번 메모리가 바뀌었다가 이 후 또 메모리 주소 변하지 않음.
	//	--------------------------------------
	//	원소 개수 - 8
	//	용량 - 9
	//	메모리 - 000001D86149F400
	//	--------------------------------------
	//	원소 개수 - 9
	//	용량 - 9
	//	메모리 - 000001D86149F400

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:18:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	vector<int> v;
	size_t old = v.capacity();

	for (int i = 0; i < 1'0000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "원소 수	- " << v.size() << endl;
			cout << "용량	- " << v.capacity() << endl;
			old = v.capacity();
		}
	}
	//	원소 수 - 1
	//	용량 - 1
	//	원소 수 - 2
	//	용량 - 2
	//	원소 수 - 3
	//	용량 - 3
	//	원소 수 - 4
	//	용량 - 4
	//	원소 수 - 5
	//	용량 - 6
	//	원소 수 - 7
	//	용량 - 9
	//	원소 수 - 10
	//	용량 - 13
	//	원소 수 - 14
	//	용량 - 19
	//	원소 수 - 20
	//	용량 - 28
	//	원소 수 - 29
	//	용량 - 42
	//	원소 수 - 43
	//	용량 - 63
	//	원소 수 - 64
	//	용량 - 94
	//	원소 수 - 95
	//	용량 - 141
	//	원소 수 - 142
	//	용량 - 211
	//	원소 수 - 212
	//	용량 - 316
	//	원소 수 - 317
	//	용량 - 474
	//	원소 수 - 475
	//	용량 - 711
	//	원소 수 - 712
	//	용량 - 1066
	//	원소 수 - 1067
	//	용량 - 1599
	//	원소 수 - 1600
	//	용량 - 2398
	//	원소 수 - 2399
	//	용량 - 3597
	//	원소 수 - 3598
	//	용량 - 5395
	//	원소 수 - 5396
	//	용량 - 8092
	//	원소 수 - 8093
	//	용량 - 12138
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 4:19:15 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	vector<int> v;
	size_t old = v.capacity();

	for (int i = 0; i < 1'0000; ++i) {
		v.push_back(i);
		if (v.capacity() != old) {
			cout << "용량	- " << v.capacity() << endl;
			old = v.capacity();
		}
	}
	//	용량이 0.5씩 늘어나고 있음. 무조건 0.5씩 늘려나가는 것은 아님.
	//	컴파일러 회사마다 조금 다름. visual studio에서는 0.5씩 늘림.
	//	용량 - 1
	//	용량 - 2
	//	용량 - 3
	//	용량 - 4
	//	용량 - 6
	//	용량 - 9
	//	용량 - 13
	//	용량 - 19
	//	용량 - 28
	//	용량 - 42
	//	용량 - 63
	//	용량 - 94
	//	용량 - 141
	//	용량 - 211
	//	용량 - 316
	//	용량 - 474
	//	용량 - 711
	//	용량 - 1066
	//	용량 - 1599
	//	용량 - 2398
	//	용량 - 3597
	//	용량 - 5395
	//	용량 - 8092
	//	용량 - 12138
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 5:02:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;
	
	//	v.push_back(STRING{ "12345" });
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x1816cffcc0, 자원메모리 : 0x2041a1d25a0
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x2041a1d28d0, 자원메모리 : 0x2041a1d25a0
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x1816cffcc0, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1430 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x2041a1d28d0, 자원메모리 : 0x2041a1d25a0

	//	v.push_back(move(STRING{ "12345" }));
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x49c9b1f750, 자원메모리 : 0x18e71d82520
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x18e71d828f0, 자원메모리 : 0x18e71d82520
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x49c9b1f750, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 995 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x18e71d828f0, 자원메모리 : 0x18e71d82520

	//	v.emplace_back(STRING{ "12345" });				// emplacing은 재료만 주면 됨.
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x368b8ffa40, 자원메모리 : 0x1ee649224c0
	//	[2] 이동생성자, 자원수 : 5, 메모리 : 0x1ee64922c90, 자원메모리 : 0x1ee649224c0
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x368b8ffa40, 자원메모리 : 0x0
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1869 bytes"
	//	[2] 소멸자, 자원수 : 5, 메모리 : 0x1ee64922c90, 자원메모리 : 0x1ee649224c0

	//	v.emplace_back("12345");						// 임시 객체를 만들지 않음
	//	[1] 생성자(char*), 자원수:5, 메모리 : 0x1f9b2f226d0, 자원메모리 : 0x1f9b2f22530
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 2332 bytes"
	//	[1] 소멸자, 자원수 : 5, 메모리 : 0x1f9b2f226d0, 자원메모리 : 0x1f9b2f22530

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-17 오후 5:10:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 17일 목요일					(7주 2일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;

	v.emplace_back("인자만 인자만 인자만");			// 객체가 만들어지는 형태 v.emplace_back(STRING{}) 로 쓰면 안됨. 재료(인자만) 써야함.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:34:38 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	vector는 어떻게 메모리를 관리하나?
//	새로 메모리를 잡는 순간만 화면 출력

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v;
	
	v.emplace_back();
	v.emplace_back("인자만 인자만 인자만");			// 객체가 만들어지는 형태 v.emplace_back(STRING{}) 로 쓰면 안됨. 재료(인자만) 써야함.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:49:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	vector<STRING> v;
	
	//	v에 최대 얼마만큼의 원소를 저장할 것인지 예측한다.
	//	예측한 만큼 공간을 확보한다 -> reserve

	ifstream in{ "main.cpp" };

	array<int, 26> a;	// 빈도

	for (int n : a)
		cout << n << " ";
	cout << endl;
	//	-85258456 32767 904872880 32758 2 32758 2 0 904877496 32758 904868685 32758 0 0 0 0 63 0 0 0 904877488 32758 904868549 32758 7 0
	//	초기화 되지 않음.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:50:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	vector<STRING> v;
	
	//	v에 최대 얼마만큼의 원소를 저장할 것인지 예측한다.
	//	예측한 만큼 공간을 확보한다 -> reserve

	ifstream in{ "main.cpp" };

	array<int, 26> a{};	// 빈도

	for (int n : a)
		cout << n << " ";
	cout << endl;
	//	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	//	초기화 됨.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:53:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<array>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//	[문제]	"main.cpp" 파일의 알파벳 빈도(frequency)를 다음과 같이 출력하라.
//	a -> 10
//	b -> 3
//	...
//	z -> 0

//---------
int main() 
//---------
{
	array<int, 26> a{};	// 빈도

	ifstream in{ "main.cpp" };

	char c;
	while (in >> c) {
		if (islower(c)) {
			a[c - 'a']++;
		}
	}

	for (int i = 0; i < a.size(); ++i)
		cout << static_cast<char>(i + 'a') << " -> " << a[i] << endl;

//	a -> 36
//	b -> 4
//	c -> 26
//	d -> 9
//	e -> 36
//	f -> 5
//	g -> 1
//	h -> 7
//	i -> 33
//	j -> 2
//	k -> 0
//	l -> 10
//	m -> 10
//	n -> 29
//	o -> 15
//	p -> 7
//	q -> 2
//	r -> 27
//	s -> 16
//	t -> 25
//	u -> 12
//	v -> 4
//	w -> 2
//	x -> 1
//	y -> 6
//	z -> 2

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 1:59:12 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.
	remove(v.begin(), v.end(), 3);		// algorithm

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	1 2 4 5 5

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:07:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.
	auto new_end = remove(v.begin(), v.end(), 3);		// algorithm
	v.erase(new_end, v.end());

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	1 2 4 5

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:11:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 3을 제거하라.	erase-remove idiom
	v.erase(remove(v.begin(), v.end(), 3), v.end());
	//	원칙을 깨는 함수가 만들어짐 (vector 전용 함수, c++20부터 제공)
	erase(v, 3);
	//	STL하면서 교수님께서 싫어하는 함수(원칙을 깨서?)

	for (int num : v)
		cout << num << ' ';
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:23:52 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 홀수를 제거하라.
	v.erase(remove_if(v.begin(), v.end(), [](int n) {
		return n & 1;
	}), v.end());

	for (int num : v)
		cout << num << ' ';
	cout << endl;
	//	2 4

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:25:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v{ 1,2,3,4,5 };		// 자료구조에서 어떠한 동작을 하는 것: 알고리즘

	//	[문제] v에서 홀수를 제거하라.
	erase_if(v, [](int n) {
		return n & 1;
	});
	// 축약 버전

	for (int num : v)
		cout << num << ' ';
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;

	// 인터페이스 함수들
	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-04-22 오후 2:41:13 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","3","4","5"};

	//	[문제] v에서 "3"을 제거하라.
	v.erase(remove(v.begin(), v.end(), "3"), v.end());

	for (const STRING& s : v)
		cout << s << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:42:00 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","3","4","5"};

	//	[문제] v에서 "3"을 제거하라.
	v.erase(remove(v.begin(), v.end(), "3"), v.end());

	cout << "v의 원소 수 - " << v.size() << endl;
	for (const STRING& s : v)
		cout << s << endl;
	//	1
	//	2
	//	4
	//	5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:44:18 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v)
		cout << s << endl;
	//	1
	//	2
	//	3
	//	4
	//	5
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:45:03 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;

	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	v.insert(v.begin() + 2, "3");

	for (const STRING& s : v)
		cout << s << endl;
	//	[1] 생성자(char*), 자원수:1, 메모리 : 0x2fe70ff7b0, 자원메모리 : 0x1f53fb308a0
	//	[2] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7c8, 자원메모리 : 0x1f53fb308b0
	//	[3] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7e0, 자원메모리 : 0x1f53fb30810
	//	[4] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff7f8, 자원메모리 : 0x1f53fb30830
	//	[5] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2ae80, 자원메모리 : 0x1f53fb30970
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2ae98, 자원메모리 : 0x1f53fb30950
	//	[7] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2aeb0, 자원메모리 : 0x1f53fb307f0
	//	[8] 복사생성자, 자원수 : 1, 메모리 : 0x1f53fb2aec8, 자원메모리 : 0x1f53fb30930
	//	[4] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7f8, 자원메모리 : 0x1f53fb30830
	//	[3] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7e0, 자원메모리 : 0x1f53fb30810
	//	[2] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7c8, 자원메모리 : 0x1f53fb308b0
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff7b0, 자원메모리 : 0x1f53fb308a0
	//	[9] 생성자(char*), 자원수 : 1, 메모리 : 0x2fe70ff770, 자원메모리 : 0x1f53fb30890
	//	[10] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282f0, 자원메모리 : 0x1f53fb30890
	//	[11] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282c0, 자원메모리 : 0x1f53fb30970
	//	[12] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb282d8, 자원메모리 : 0x1f53fb30950
	//	[13] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb28308, 자원메모리 : 0x1f53fb307f0
	//	[14] 이동생성자, 자원수 : 1, 메모리 : 0x1f53fb28320, 자원메모리 : 0x1f53fb30930
	//	[5] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2ae80, 자원메모리 : 0x0
	//	[6] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2ae98, 자원메모리 : 0x0
	//	[7] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2aeb0, 자원메모리 : 0x0
	//	[8] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb2aec8, 자원메모리 : 0x0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x2fe70ff770, 자원메모리 : 0x0
	//	1
	//	2
	//	3
	//	4
	//	5
	//	"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 1060 bytes"
	//	[11] 소멸자, 자원수:1, 메모리 : 0x1f53fb282c0, 자원메모리 : 0x1f53fb30970
	//	[12] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb282d8, 자원메모리 : 0x1f53fb30950
	//	[10] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb282f0, 자원메모리 : 0x1f53fb30890
	//	[13] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb28308, 자원메모리 : 0x1f53fb307f0
	//	[14] 소멸자, 자원수 : 1, 메모리 : 0x1f53fb28320, 자원메모리 : 0x1f53fb30930
	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:46:05 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};

	//	[문제] v에서 "2"와 "4" 사이에 "3"을 삽입하라.
	관찰 = true;
	v.insert(v.begin() + 2, "3");
	관찰 = false;
	//	[9] 생성자(char*), 자원수:1, 메모리 : 0x69b78ff860, 자원메모리 : 0x1d7e35b2590
	//	[10] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0f0, 자원메모리 : 0x1d7e35b2590
	//	[11] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0c0, 자원메모리 : 0x1d7e35b2580
	//	[12] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab0d8, 자원메모리 : 0x1d7e35b2460
	//	[13] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab108, 자원메모리 : 0x1d7e35b2470
	//	[14] 이동생성자, 자원수 : 1, 메모리 : 0x1d7e35ab120, 자원메모리 : 0x1d7e35b24d0
	//	[5] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aab80, 자원메모리 : 0x0
	//	[6] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aab98, 자원메모리 : 0x0
	//	[7] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aabb0, 자원메모리 : 0x0
	//	[8] 소멸자, 자원수 : 1, 메모리 : 0x1d7e35aabc8, 자원메모리 : 0x0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x69b78ff860, 자원메모리 : 0x0

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:49:25 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","2","4","5"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "3"을 제거하라.
	관찰 = true;
	erase(v, "3");
	관찰 = false;
	//	[9] 생성자(char*), 자원수:1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e8824e0
	//	[9] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e8824e0
	//	[10] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[10] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[11] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882520
	//	[11] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882520
	//	[12] 생성자(char*), 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490
	//	[12] 소멸자, 자원수 : 1, 메모리 : 0x9da60ff9b0, 자원메모리 : 0x1db8e882490

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:52:33 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","333","4444","55555"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "3"을 제거하라.
	관찰 = true;
	remove(v.begin(), v.end(), "333");
	관찰 = false;
	//	[11] 생성자(char*), 자원수:3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122590
	//	[11] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122590
	//	[12] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122430
	//	[12] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122430
	//	[13] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e6271224f0
	//	[13] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e6271224f0
	//	[14] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122490
	//	[14] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122490
	//	[8] 이동할당연산자, 자원수 : 4, 메모리 : 0x1e6271239d0, 자원메모리 : 0x1e627122420
	//	[15] 생성자(char*), 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122470
	//	[15] 소멸자, 자원수 : 3, 메모리 : 0x643bf0fb40, 자원메모리 : 0x1e627122470
	//	[9] 이동할당연산자, 자원수 : 5, 메모리 : 0x1e627123cd0, 자원메모리 : 0x1e6271224b0

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:54:41 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};
	//	자료구조가 만능이라 해서 막 쓰면 안 됨.

	//	[문제] v에서 "333"을 삽입하라.
	관찰 = true;
	v.insert(++ ++v.begin(), "333");
	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	//	[9] 생성자(char*), 자원수:3, 메모리 : 0x51ad30fd70, 자원메모리 : 0x17e1a4b24d0
	//	[10] 이동생성자, 자원수 : 3, 메모리 : 0x17e1a4b3910, 자원메모리 : 0x17e1a4b24d0
	//	[9] 소멸자, 자원수 : 3, 메모리 : 0x51ad30fd70, 자원메모리 : 0x0
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:56:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};

	//	[문제] v에서 "333"을 삽입하라.
	STRING temp{ "333" };
	관찰 = true;
	v.insert(++ ++v.begin(), temp);
	관찰 = false;
	//	[      10] 복사생성자      , 자원수:3         , 메모리:0x1c618753e80, 자원메모리:0x1c618752570

	for (const STRING& s : v)
		cout << s << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 2:56:47 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<algorithm>
#include<list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","4444","55555"};

	//	[문제] v에서 "333"을 삽입하라.
	관찰 = true;
	v.emplace(++++v.begin(), "333");
	관찰 = false;
	//	[       9] 생성자(char*)   , 자원수:3         , 메모리:0x17af8c93b20, 자원메모리:0x17af8c925a0

	for (const STRING& s : v)
		cout << s << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:00:28 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d;
	// array 제외 전부 동적 메모리 관리
	
	cout << "VS에서 x64일때 deque의 크기 - " << sizeof d << endl;
	//	VS에서 x64일때 deque의 크기 - 40

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:02:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d{"1","22","333","4444","55555"};
	// array 제외 전부 동적 메모리 관리
	
	for (int i = 0; i < d.size(); ++i)
		cout << &d[i] << endl;
	//	0000021975DA2B90
	//	0000021975DA2B10
	//	0000021975DA2B30
	//	0000021975DA2CB0
	//	0000021975DA2A50
	//	얘들이 같은 contigous메모리에 있어야 하는데 이상하다 라고 하셨습니다.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:05:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;
	deque<STRING> d{"1","22","333","4444","55555"};
	// array 제외 전부 동적 메모리 관리
	관찰 = false;

	for (int i = 0; i < d.size(); ++i)
		cout << &d[i] << endl;

	//	[1] 생성자(char*), 자원수:1, 메모리 : 0xc6b86ffb10, 자원메모리 : 0x2b01adf24e0
	//	[2] 생성자(char*), 자원수 : 2, 메모리 : 0xc6b86ffb28, 자원메모리 : 0x2b01adf2480
	//	[3] 생성자(char*), 자원수 : 3, 메모리 : 0xc6b86ffb40, 자원메모리 : 0x2b01adf2510
	//	[4] 생성자(char*), 자원수 : 4, 메모리 : 0xc6b86ffb58, 자원메모리 : 0x2b01adf25a0
	//	[5] 생성자(char*), 자원수 : 5, 메모리 : 0xc6b86ffb70, 자원메모리 : 0x2b01adf25b0
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x2b01adf2af0, 자원메모리 : 0x2b01adf2500
	//	[7] 복사생성자, 자원수 : 2, 메모리 : 0x2b01adf2b50, 자원메모리 : 0x2b01adf2520
	//	[8] 복사생성자, 자원수 : 3, 메모리 : 0x2b01adf2c90, 자원메모리 : 0x2b01adf24a0
	//	[9] 복사생성자, 자원수 : 4, 메모리 : 0x2b01adf2d30, 자원메모리 : 0x2b01adf2470
	//	[10] 복사생성자, 자원수 : 5, 메모리 : 0x2b01adf29d0, 자원메모리 : 0x2b01adf2420
	//	[5] 소멸자, 자원수 : 5, 메모리 : 0xc6b86ffb70, 자원메모리 : 0x2b01adf25b0
	//	[4] 소멸자, 자원수 : 4, 메모리 : 0xc6b86ffb58, 자원메모리 : 0x2b01adf25a0
	//	[3] 소멸자, 자원수 : 3, 메모리 : 0xc6b86ffb40, 자원메모리 : 0x2b01adf2510
	//	[2] 소멸자, 자원수 : 2, 메모리 : 0xc6b86ffb28, 자원메모리 : 0x2b01adf2480
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0xc6b86ffb10, 자원메모리 : 0x2b01adf24e0
	//	000002B01ADF2AF0
	//	000002B01ADF2B50
	//	000002B01ADF2C90
	//	000002B01ADF2D30
	//	000002B01ADF29D0

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:07:24 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<STRING> d{"1","22","333","4444","55555"};

	d.push_front("0");
	d.push_front("-1");

	for (const STRING& d : d)
		cout << d << endl;

	//	-1
	//	0
	//	1
	//	22
	//	333
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-22 오후 3:09:53 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 22일 화요일					(8주 1일)
//	중간고사	(30) -	4월 24일(8주 2일) 목요일	-	시험장소 E동 320 (준비 끝난 후 60분)
//	5월 2일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T> - vector보다 더 많은 원소를 담을 수 있다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;
	deque<STRING> d{"1","22","333","4444","55555"};

	for (const STRING& s : d)
		cout << (void*)&s << endl;
	관찰 = false;

	//	[1] 생성자(char*), 자원수:1, 메모리 : 0x1cedddf7b0, 자원메모리 : 0x12b24902450
	//	[2] 생성자(char*), 자원수 : 2, 메모리 : 0x1cedddf7c8, 자원메모리 : 0x12b24902460
	//	[3] 생성자(char*), 자원수 : 3, 메모리 : 0x1cedddf7e0, 자원메모리 : 0x12b249025a0
	//	[4] 생성자(char*), 자원수 : 4, 메모리 : 0x1cedddf7f8, 자원메모리 : 0x12b24902540
	//	[5] 생성자(char*), 자원수 : 5, 메모리 : 0x1cedddf810, 자원메모리 : 0x12b24902580
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x12b24902db0, 자원메모리 : 0x12b249025b0
	//	[7] 복사생성자, 자원수 : 2, 메모리 : 0x12b24902930, 자원메모리 : 0x12b24902550
	//	[8] 복사생성자, 자원수 : 3, 메모리 : 0x12b24902ef0, 자원메모리 : 0x12b249024f0
	//	[9] 복사생성자, 자원수 : 4, 메모리 : 0x12b24902ad0, 자원메모리 : 0x12b24902590
	//	[10] 복사생성자, 자원수 : 5, 메모리 : 0x12b24902f70, 자원메모리 : 0x12b24902440
	//	[5] 소멸자, 자원수 : 5, 메모리 : 0x1cedddf810, 자원메모리 : 0x12b24902580
	//	[4] 소멸자, 자원수 : 4, 메모리 : 0x1cedddf7f8, 자원메모리 : 0x12b24902540
	//	[3] 소멸자, 자원수 : 3, 메모리 : 0x1cedddf7e0, 자원메모리 : 0x12b249025a0
	//	[2] 소멸자, 자원수 : 2, 메모리 : 0x1cedddf7c8, 자원메모리 : 0x12b24902460
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0x1cedddf7b0, 자원메모리 : 0x12b24902450
	// 해당 문제는 시험보고 나서 찾아볼 것

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-29 오후 2:29:36 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 29일 화요일					(9주 1일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T>  - vector보다 더 많은 원소를 담을 수 있다.
//		
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","22","333","4444","55555" };		// 그림 그릴 수 있어야 함. 기말 때 그림 그려봐라.

	// 333 지우기 관찰
//	관찰 = true;
	erase(v, "333");
//	관찰 = false;

	for (const STRING& s : v)
		cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-29 오후 2:30:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 29일 화요일					(9주 1일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T>  - vector보다 더 많은 원소를 담을 수 있다.
//		
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<STRING> v{ "1","22","333","4444","55555" };		// 그림 그릴 수 있어야 함. 기말 때 그림 그려봐라.

	// 333 지우기 관찰
	관찰 = true;
	erase(v, "333");
	관찰 = false;
	// 객체의 움직임
	//	[11] 생성자(char*), 자원수:3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a24d0
	//	[11] 소멸자, 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a24d0
	//	[12] 생성자(char*), 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a24d0
	//	[12] 소멸자, 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a24d0
	//	[13] 생성자(char*), 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a2580
	//	[13] 소멸자, 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a2580
	//	[14] 생성자(char*), 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a2550
	//	[14] 소멸자, 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a2550
	//	[8] 이동할당연산자, 자원수 : 4, 메모리 : 0x2a5cc09abf0, 자원메모리 : 0x2a5cc0a2450
	//	[15] 생성자(char*), 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a25d0
	//	[15] 소멸자, 자원수 : 3, 메모리 : 0xf5556ffca0, 자원메모리 : 0x2a5cc0a25d0
	//	[9] 이동할당연산자, 자원수 : 5, 메모리 : 0x2a5cc09ac08, 자원메모리 : 0x2a5cc0a25e0
	//	[10] 소멸자, 자원수 : 0, 메모리 : 0x2a5cc09ac20, 자원메모리 : 0x0

	//for (const STRING& s : v)
	//	cout << s << endl;
	//	1
	//	22
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-29 오후 2:31:16 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 29일 화요일					(9주 1일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T>  - vector보다 더 많은 원소를 담을 수 있다.
//		
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","333","4444","55555" };		// 그림 그릴 수 있어야 함. 기말 때 그림 그려봐라.

	// 333 지우기 관찰
	관찰 = true;
	erase(v, "333");
	관찰 = false;
	//	[11] 생성자(char*), 자원수:3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa6924b0
	//	[11] 소멸자, 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa6924b0
	//	[12] 생성자(char*), 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692500
	//	[12] 소멸자, 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692500
	//	[13] 생성자(char*), 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692580
	//	[13] 소멸자, 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692580
	//	[14] 생성자(char*), 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa6924c0
	//	[14] 소멸자, 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa6924c0
	//	[15] 생성자(char*), 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692440
	//	[15] 소멸자, 자원수 : 3, 메모리 : 0x27842ff650, 자원메모리 : 0x153fa692440
	//	[8] 소멸자, 자원수 : 3, 메모리 : 0x153fa693ee0, 자원메모리 : 0x153fa6924e0

	//for (const STRING& s : v)
	//	cout << s << endl;
	//	1
	//	22
	//	4444
	//	55555

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-29 오후 2:45:51 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 29일 화요일					(9주 1일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T>  - vector보다 더 많은 원소를 담을 수 있다.
//		
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<STRING> v{ "1","22","333","4444","55555" };		// 그림 그릴 수 있어야 함. 기말 때 그림 그려봐라.

	// 333 지우기 관찰
	관찰 = true;
	v.remove("333");
	관찰 = false;
	//	[11] 생성자(char*), 자원수:3, 메모리 : 0x1161cf7f0, 자원메모리 : 0x19779f725e0
	//	[8] 소멸자, 자원수 : 3, 메모리 : 0x19779f73ac0, 자원메모리 : 0x19779f72470
	//	[11] 소멸자, 자원수 : 3, 메모리 : 0x1161cf7f0, 자원메모리 : 0x19779f725e0

	//for (const STRING& s : v)
	//	cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-04-29 오후 3:06:56 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				4월 29일 화요일					(9주 1일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - dynamic(run-time) array
//		deque<T>  - vector보다 더 많은 원소를 담을 수 있다.
//		
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	관찰 = true;
	list<STRING> cont{ "1","333","55555","4444","22" };		// 그림 그릴 수 있어야 함. 기말 때 그림 그려봐라.
	//	{}안 string들이 임시 객체로 생성(생성자) ---> 임시 객체들이 cont 안으로 복사 생성(복사 생성자) => 10까지 찍힐 것임
	//	[1] 생성자(char*), 자원수:1, 메모리 : 0xd23e8ffa50, 자원메모리 : 0x1dcc4fa4340
	//	[2] 생성자(char*), 자원수 : 3, 메모리 : 0xd23e8ffa68, 자원메모리 : 0x1dcc4fa4350
	//	[3] 생성자(char*), 자원수 : 5, 메모리 : 0xd23e8ffa80, 자원메모리 : 0x1dcc4fa43d0
	//	[4] 생성자(char*), 자원수 : 4, 메모리 : 0xd23e8ffa98, 자원메모리 : 0x1dcc4fa4380
	//	[5] 생성자(char*), 자원수 : 2, 메모리 : 0xd23e8ffab0, 자원메모리 : 0x1dcc4fa4320
	//	[6] 복사생성자, 자원수 : 1, 메모리 : 0x1dcc4fa6c80, 자원메모리 : 0x1dcc4fa43a0
	//	[7] 복사생성자, 자원수 : 3, 메모리 : 0x1dcc4fa6d40, 자원메모리 : 0x1dcc4fa4280
	//	[8] 복사생성자, 자원수 : 5, 메모리 : 0x1dcc4fa6d70, 자원메모리 : 0x1dcc4fa4330
	//	[9] 복사생성자, 자원수 : 4, 메모리 : 0x1dcc4fa6bc0, 자원메모리 : 0x1dcc4fa4370
	//	[10] 복사생성자, 자원수 : 2, 메모리 : 0x1dcc4fa6c50, 자원메모리 : 0x1dcc4fa4290
	//	[5] 소멸자, 자원수 : 2, 메모리 : 0xd23e8ffab0, 자원메모리 : 0x1dcc4fa4320
	//	[4] 소멸자, 자원수 : 4, 메모리 : 0xd23e8ffa98, 자원메모리 : 0x1dcc4fa4380
	//	[3] 소멸자, 자원수 : 5, 메모리 : 0xd23e8ffa80, 자원메모리 : 0x1dcc4fa43d0
	//	[2] 소멸자, 자원수 : 3, 메모리 : 0xd23e8ffa68, 자원메모리 : 0x1dcc4fa4350
	//	[1] 소멸자, 자원수 : 1, 메모리 : 0xd23e8ffa50, 자원메모리 : 0x1dcc4fa4340

	
	관찰 = false;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 3:34:21 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include<deque>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v;

	cout << "최대 개수 - " << v.max_size() << endl;
	// 최대 개수는 무의미함.
	// 최대 개수 - 4611686018427387903 : 컴마다 다를 수 있음.
	
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 3:48:06 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//class Test {
//	char x[1'000'000];			// 1메가 정도로 맞춤
//};

//---------
int main() 
//---------
{
	{	// 교수님 컴 "최대 원소 수 - 18'207"
		//vector<Test> v;
		//int cnt{};
		//try{
		//	while (true) {
		//		v.emplace_back();
		//		// 뺑뺑이 돌다가 죽음
		//		// ===>예외 필요
		//		cout << ++cnt << endl;
		//	}
		//}
		//catch (...) {
		//	cout << "최대 원소 수 - " << v.size() << endl;
		//}
	}

	{	// 교수님 컴 "최대 원소 수 - 38'520"
		//deque<Test> d;
		//int cnt{};
		//try {
		//	while (true) {
		//		d.emplace_back();
		//		// 뺑뺑이 돌다가 죽음
		//		// ===>예외 필요
		//		cout << ++cnt << endl;
		//	}
		//}
		//catch (...) {
		//	cout << "최대 원소 수 - " << d.size() << endl;
		//}
	}
	
	list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	//	[문제] cont의 모든 원소를 출력하라.
	for (int num : cont)
		cout << num << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 3:52:56 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	//	[문제] cont의 두 번째 원소부터 끝까지 출력하라.
	//	벡터일 때의 정답:
	for (int i = 1; i < v.size(); ++i)
		cout << v[i] << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:02:53 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	//	[문제] cont의 두 번째 원소부터 끝까지 출력하라.
	//	벡터일 때의 정답:
	for (int i = 1; i < v.size(); ++i)
		cout << v[i] << " ";
	cout << endl;

	// [] 이 기호는 메모리가 contiguous한 cont일때 사용할 수 있음.
	// int a[]
	// array<int,N>
	// vector<int>
	// deque<int>
	// string
	// 이 중 STL의 기본적인 cont는 array, vector, deque

	// list는 어떻게? 이럴 때 반복자가 필요.
	// list<int>::iterator beg = cont.begin();		// 포인터가 아님. 클래스 자료형식
	//	리스트일 때의 정답:
	auto beg = cont.begin();
	++beg;
	for (auto i = beg; i != cont.end(); ++i)
	// list는 연결 리스트 형식?의 cont이므로 list의 원소를 가리키는 i에 i<cont.end()는 쓰지 못함.
		cout << *i << " ";
	cout << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:05:57 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,2,3,4,5,6,7,8,9,10 };

	//	[문제] cont의 두 번째 원소부터 끝까지 출력하라.
	auto beg = cont.begin();
	beg.operator++();

	// list<int>::iterator beg = cont.begin();		// 포인터가 아님. 클래스 자료형식
	for (auto i = ++cont.begin(); i != cont.end(); ++i)		
		cout << *i << " ";
	cout << endl;


	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:08:23 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<ranges>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] cont의 원소를 거꾸로 출력하라.
	for (auto i = cont.begin(); i != cont.end(); ++i)
		cout << *i << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:10:02 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<unordered_set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };
	unordered_set<int> cont1{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] cont의 원소를 거꾸로 출력하라.
	//for (auto i = cont.begin(); i != cont.end(); ++i)
	//	cout << *i << " ";
	//cout << endl;
	// 1 3 5 7 9 2 4 6 8 10

	for (auto i = cont1.begin(); i != cont1.end(); ++i)
		cout << *i << " ";
	cout << endl;
	// 9 1 3 5 7 2 4 6 8 10

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:10:53 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include<set>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };
	set<int> cont1{ 1,3,5,7,9,2,4,6,8,10 };

	//	[문제] cont의 원소를 거꾸로 출력하라.
	//for (auto i = cont.begin(); i != cont.end(); ++i)
	//	cout << *i << " ";
	//cout << endl;
	// 1 3 5 7 9 2 4 6 8 10

	for (auto i = cont1.begin(); i != cont1.end(); ++i)
		cout << *i << " ";
	cout << endl;
	// 1 2 3 4 5 6 7 8 9 10

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:13:49 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include <list>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<int> cont{ 1,3,5,7,9,2,4,6,8,10 };		// }; == end ===> }; 이 자리 값을 찍고 싶어: 이전 원소 10을 찍는 사기 행각

	//	[문제] cont의 원소를 거꾸로 출력하라.
	for (auto i = cont.rbegin(); i != cont.rend(); ++i)		// cppreference - std::reverse_iterator
		cout << i.operator*() << " ";
	cout << endl;
	// 10 8 6 4 2 9 7 5 3 1

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:38:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;

	// 인터페이스 함수들
	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-01 오후 4:38:09 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p = std::make_unique<char[]>(str.len);
	str.p.reset(s.data());
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 4:38:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	list<STRING> 단어들;

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s;
	// pxWPxW----------------------------------------------------------------------------------
	//while (in >> s)
	//	단어들.push_back(s);

	//for (const STRING& 단어 : 단어들)
	//	cout << 단어 << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:41:50 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	list<STRING> 단어들;

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	// p?
	//while (in >> s)
	//	단어들.push_back(s);

	//for (const STRING& 단어 : 단어들)
	//	cout << 단어 << endl;

	//save("STRING.h");
	//save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:43:28 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	std::cout << s << std::endl;
	str.len = s.length();
	std::cout << str.len << std::endl;
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	str.p.reset(s.data());
	return is;

	////------------------------------------------------------------------------------------------------
	//98
	// 자원을 훔쳐올려고 이런 코드 썼다가 망함.
	// 메모리 주소 복사? 문제?
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 4:46:07 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	str.p.reset(s.data());
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 4:46:07 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	list<STRING> 단어들;

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	STRING s;
	in >> s;
	cout << s << endl;
	//while (in >> s)
	//	단어들.push_back(s);

	//for (const STRING& 단어 : 단어들)
	//	cout << 단어 << endl;

	//save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 4:47:09 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	list<STRING> 단어들;

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	STRING s;
	while (in >> s)
		단어들.push_back(s);

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;

//	//
//	2025
//		STL
//		화56목78
//		5월
//		1일
//		목요일
//		(9주
//			2일)
//		//
//		5월
//		6일(화요일)
//		->
//		6월
//		19일(예정)
//
//		//
//		STL
//		Container
//		-
//		Container
//		are
//		objects
//		that
//		store
//		other
//		objects.
//		//
//		1.
//		Sequence
//		Containers
//		//
//		array<T, N>
//		//
//		vector<T>
//		-
//		push_back()
//		O(1)
//		//
//		deque<T>
//		-
//		push_front()
//		/
//		push_back()
//		O(1)
//		//
//		list<T>
//		-
//		node
//		기반,
//		임의의
//		위치에서
//		삽입과
//		삭제
//		O(1)
//
//#include
//		<iostream>
//#include
//		<list>
//#include<fstream>
//#include"STRING.h"
//#include
//		"save.h"
//		using
//		namespace
//		std;
//	extern
//		bool
//		관찰;
//	//
//	관찰하려면
//		true로
//		설정
//		//---------
//		int
//		main()
//		//---------
//	{
//		//
//		[문제]
//		"main.cpp"의
//			단어를
//			list에
//			저장하라.
//			//
//			찾을
//			단어를
//			물어봐서
//			없으면
//			없다.
//			있으면
//			list의
//			몇
//			번째
//			단어인지
//			출력해
//			주자.
//			list<STRING>
//			단어들;
//		ifstream
//			in{ "main.cpp" };
//		if
//			(not
//				in)
//			return
//			20250501;
//		STRING
//			s;
//		while
//			(in
//				>>
//				s)
//			단어들.push_back(s);
//		for
//			(const
//				STRING&
//				단어
//				:
//				단어들)
//			cout
//			<<
//			단어
//			<<
//			endl;
//		save("main.cpp");
//	}

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 5:01:04 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	return std::equal(&p[0], &p[len], &rhs.p[0]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 5:01:04 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };
	while (true) {
		cout << "찾으실 단어? ";
		STRING 단어;
		cin >> 단어;

		if (단어 == "z")break;

		auto res = find(단어들.begin(), 단어들.end(), 단어);		// 반복자로 반환
		if (res == 단어들.end())
			cout << 단어 << " - 없는 단어입니다." << endl;
		else
			cout << "찾았습니다." << endl;
	}
	// 오류: 없는 단어 iff도 찾았다고 함.

	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-01 오후 5:04:57 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	std::cout << *this << "<--->" << rhs << std::endl;
	return std::equal(&p[0], &p[len], &rhs.p[0], &rhs.p[len]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 5:04:57 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };
	while (true) {
		cout << "찾으실 단어? ";
		STRING 단어;
		cin >> 단어;

		if (단어 == "z")break;

		auto res = find(단어들.begin(), 단어들.end(), 단어);		// 반복자로 반환
		if (res == 단어들.end())
			cout << 단어 << " - 없는 단어입니다." << endl;
		else
			cout << "찾았습니다." << endl;
	}

	save("STRING.cpp");
	save("main.cpp");

	//in{"main.cpp"};<--->iff
	//if<--->iff
	//찾았습니다.
	// ----> if와 iff가 같다는 판정.
}


=================================================
저장한 시간: 2025-05-01 오후 5:08:30 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	//if (len != rhs.len)
	//	return false;
	return std::equal(&p[0], &p[len], &rhs.p[0], &rhs.p[rhs.len]);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-01 오후 5:08:30 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 1일 목요일					(9주 2일)
//	5월 6일(화요일) -> 6월 19일(예정)
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	save("STRING.cpp");
	save("main.cpp");

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };
	while (true) {
		cout << "찾으실 단어? ";
		STRING 단어;
		cin >> 단어;

		auto res = find(단어들.begin(), 단어들.end(), 단어);		// 반복자로 반환
		if (res == 단어들.end())
			cout << 단어 << " - 없는 단어입니다." << endl;
		else
			cout << "찾았습니다." << endl;
	}


}


=================================================
저장한 시간: 2025-05-08 오후 4:03:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] "main.cpp"의 단어를 list에 저장하라.
	//	찾을 단어를 물어봐서 없으면 없다. 있으면 list의 몇 번째 단어인지 출력해 주자.

	save("main.cpp");

	ifstream in{"main.cpp"};
	if (not in)
		return 20250501;

	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };

	for (const STRING& 단어 : 단어들)
		cout << 단어 << endl;


	while (true) {
		cout << "찾으실 단어? ";
		STRING 단어;
		cin >> 단어;

		auto p = find(단어들.begin(), 단어들.end(), 단어);		// 반복자로 반환
		if (p == 단어들.end())
			cout << 단어 << " - 없는 단어입니다." << endl;
		else {
			cout << "찾았습니다." <<std::distance(단어들.begin(), p) + 1 << endl;
		}
	}

	// find(.begin(),.end(),val);	-----> O(N)
	//			range
	// 못 찾았을 때 end위치 return
	// 알고리즘은 c++20에서 바뀜
	// STL에서 알고리즘은 세가지로 구분
	//	값을 바꾸지 않는 알고리즘
	//	값을 바꾸는 알고리즘
	//	정렬하는 알고리즘

}


=================================================
저장한 시간: 2025-05-08 오후 4:14:01 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] 길이가 5인 단어만 화면에 출력하라.

	save("main.cpp");

	ifstream in{ "main.cpp" };
	if (not in)
		return 20250508;
	
	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };

	for (const STRING& 단어:단어들) {
		if (단어.size() == 5) 
			cout << 단어 << endl;
	}
	//	(10주
	//	store
	//	other
	//	기반,
	//	using
	//	관찰;
	//	endl;
}


=================================================
저장한 시간: 2025-05-08 오후 4:24:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] 길이가 5인 단어만 화면에 출력하라.

	save("main.cpp");

	ifstream in{ "main.cpp" };
	if (not in)
		return 20250508;
	
	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };
	
	copy(단어들.begin(), 단어들.end(), ostream_iterator<STRING>{cout});
	//copy(단어들.begin(), 단어들.end(), 화면);
	// 화면 : 데이터가 흘러들어가는 종착점
	// 키보드는 입력스트림으로 표현 가능
	// ostream_iterator : 고급 출력, 타입 지정 가능, 출력 관련 뭔가가 코딩 되어 있어야 함.
	//------------------------------------------------------------------------------------------------//2025STL화56목785월8일목요일(10주1일)//6월19일목요일15주2일-기말시험//------------------------------------------------------------------------------------------------//STLContainer-Containerareobjectsthatstoreotherobjects.//1.SequenceContainers//array<T,N>//vector<T>-push_back()O(1)//deque<T>-push_front()/push_back()O(1)//list<T>-node기반,임의의위치에서삽입과삭제O(1)//------------------------------------------------------------------------------------------------#include<iostream>#include<list>#include<fstream>#include<algorithm>#include"STRING.h"#include"save.h"usingnamespacestd;externbool관찰;//관찰하려면true로설정//---------intmain()//---------{//[문제]길이가5인단어만화면에출력하라.save("main.cpp");ifstreamin{"main.cpp"};if(notin)return20250508;list<STRING>단어들{istream_iterator<STRING>{in},{}};copy(단어들.begin(),단어들.end(),ostream_iterator<STRING>{cout});//copy(단어들.begin(),단어들.end(),화면);//화면:데이터가흘러들어가는종착점//키보드는입력스트림으로표현가능//ostream_iterator:고급출력,타입지정가능,출력관련뭔가가코딩되어있어야함.//{//autop=find_if(p,단어들.end(),[](constSTRING&단어){//return5==단어.size();//});//if(p!=단어들.end())//cout<<*p<<endl;//}//:집에서스스로}

	//{
	//	auto p = find_if(p, 단어들.end(), [](const STRING& 단어) {
	//		return 5 == 단어.size();
	//		});
	//	if (p != 단어들.end())
	//		cout << *p << endl;
	//}
	//	: 집에서 스스로

}


=================================================
저장한 시간: 2025-05-08 오후 4:27:02 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	[문제] 길이가 5인 단어만 화면에 출력하라.

	save("main.cpp");

	ifstream in{ "main.cpp" };
	if (not in)
		return 20250508;
	
	list<STRING> 단어들{ istream_iterator<STRING>{in},{} };
	
	copy_if(단어들.begin(), 단어들.end(), ostream_iterator<STRING>{cout, "\n"}, [](const STRING& 단어) {
		return 5 == 단어.size();
	});
	//copy(단어들.begin(), 단어들.end(), 화면);
	// 화면 : 데이터가 흘러들어가는 종착점
	// 키보드는 입력스트림으로 표현 가능
	// ostream_iterator : 고급 출력, 타입 지정 가능, 출력 관련 뭔가가 코딩 되어 있어야 함.
	//	(10주
	//	store
	//	other
	//	기반,
	//	using
	//	관찰;
	//	단어)
	//	출력,
	//	가능,
	//	단어)
	//	endl;
	
	//{
	//	auto p = find_if(p, 단어들.end(), [](const STRING& 단어) {
	//		return 5 == 단어.size();
	//		});
	//	if (p != 단어들.end())
	//		cout << *p << endl;
	//}
	//	: 집에서 스스로

}


=================================================
저장한 시간: 2025-05-08 오후 4:34:52 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<string> 목록1{ "1","55555","333" };
	list<string> 목록2{ "4444","22"};
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;

	//save("STRING.h");
	//save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:35:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<string> 목록1{ "1","55555","333" };
	list<string> 목록2{ "4444","22"};
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	//1 4444 22 55555 333	--->	 "1" < "4444"

	for (const string& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;
	// 아무것도 담겨있지 않음

	//save("STRING.h");
	//save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:38:42 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	list<string> 목록1{ "1","55555","333" };
	list<string> 목록2{ "4444","22"};
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	// 정렬 후 merge해야 한다
	// merge가 목록1 값과 목록2 값은 비교하여 넣지만, 자기 자신과는 비교하여 넣는 게 아닌듯.

	목록1.sort();
	목록2.sort();

	for (const string& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	//1 22 333 4444 55555
	
	for (const string& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	//save("STRING.h");
	//save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:44:28 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//	>  연산자															2025.5.8
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;
	bool operator<(const STRING& rhs) const;// 2025.05.08

	// 인터페이스 함수들
	size_t size() const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-08 오후 4:44:28 목요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	//if (len != rhs.len)
	//	return false;
	return std::equal(&p[0], &p[len], &rhs.p[0], &rhs.p[rhs.len]);
}

bool STRING::operator<(const STRING& rhs) const				// 2025.05.08
{
	return std::lexicographical_compare(p.get(), p.get() + len,
		rhs.p.get(), rhs.p.get() + rhs.len);
}

size_t STRING::size() const 
{
	return len;
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-08 오후 4:44:28 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	// STRING이 안돌아갔던 이유: 기본정렬이 안되어 있어서? operator less 코딩하러 ㄱㄱ
	list<STRING> 목록1{ "1","55555","333" };
	list<STRING> 목록2{ "4444","22"};
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	// 정렬 후 merge해야 한다
	// merge가 목록1 값과 목록2 값은 비교하여 넣지만, 자기 자신과는 비교하여 넣는 게 아닌듯.

	목록1.sort();
	목록2.sort();

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	
	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:45:42 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	// STRING이 안돌아갔던 이유: 기본정렬이 안되어 있어서? operator less 코딩하러 ㄱㄱ
	list<STRING> 목록1{ "1","55555","333" };
	list<STRING> 목록2{ "4444","22"};

	목록1.sort();
	목록2.sort();
	
	관찰 = true;
	// 관찰에 아무것도 안 뜸. 움직이지 않고 merge됨?
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	// 정렬 후 merge해야 한다
	// merge가 목록1 값과 목록2 값은 비교하여 넣지만, 자기 자신과는 비교하여 넣는 게 아닌듯.

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	
	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;
;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:46:40 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	// STRING이 안돌아갔던 이유: 기본정렬이 안되어 있어서? operator less 코딩하러 ㄱㄱ
	list<STRING> 목록1{ "1","55555","333" };
	list<STRING> 목록2{ "4444","22"};

	관찰 = true;
	// sort도 마찬가지
	목록1.sort();
	목록2.sort();
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	// 정렬 후 merge해야 한다
	// merge가 목록1 값과 목록2 값은 비교하여 넣지만, 자기 자신과는 비교하여 넣는 게 아닌듯.

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	
	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;
;
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:47:18 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T> - push_back() O(1)
//		deque<T>  - push_front() / push_back() O(1)
//		list<T>	  - node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//					대표 동작 : sort(), unique(), merge(), splice();
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	// STRING이 안돌아갔던 이유: 기본정렬이 안되어 있어서? operator less 코딩하러 ㄱㄱ
	관찰 = true;
//	[       1] 생성자(char*)   , 자원수:1         , 메모리:0x3b93effdd0, 자원메모리:0x2366bba36a0
//	[       2] 생성자(char*)   , 자원수:5         , 메모리:0x3b93effde8, 자원메모리:0x2366bba3660
//	[       3] 생성자(char*)   , 자원수:3         , 메모리:0x3b93effe00, 자원메모리:0x2366bba35d0
//	[       4] 복사생성자      , 자원수:1         , 메모리:0x2366bba6510, 자원메모리:0x2366bba3670
//	[       5] 복사생성자      , 자원수:5         , 메모리:0x2366bba6540, 자원메모리:0x2366bba36b0
//	[       6] 복사생성자      , 자원수:3         , 메모리:0x2366bba65a0, 자원메모리:0x2366bba3610
//	[       3] 소멸자          , 자원수:3         , 메모리:0x3b93effe00, 자원메모리:0x2366bba35d0
//	[       2] 소멸자          , 자원수:5         , 메모리:0x3b93effde8, 자원메모리:0x2366bba3660
//	[       1] 소멸자          , 자원수:1         , 메모리:0x3b93effdd0, 자원메모리:0x2366bba36a0
//	[       7] 생성자(char*)   , 자원수:4         , 메모리:0x3b93effda0, 자원메모리:0x2366bba3620
//	[       8] 생성자(char*)   , 자원수:2         , 메모리:0x3b93effdb8, 자원메모리:0x2366bba3630
//	[       9] 복사생성자      , 자원수:4         , 메모리:0x2366bba6960, 자원메모리:0x2366bba35b0
//	[      10] 복사생성자      , 자원수:2         , 메모리:0x2366bba6a20, 자원메모리:0x2366bba3640
//	[       8] 소멸자          , 자원수:2         , 메모리:0x3b93effdb8, 자원메모리:0x2366bba3630
//	[       7] 소멸자          , 자원수:4         , 메모리:0x3b93effda0, 자원메모리:0x2366bba3620
	list<STRING> 목록1{ "1","55555","333" };
	list<STRING> 목록2{ "4444","22"};

	목록1.sort();
	목록2.sort();
	
	목록1.merge(목록2);
	// rvalue , 목록2를 목록1이 가져가서 목록2 없어짐.

	// 정렬 후 merge해야 한다
	// merge가 목록1 값과 목록2 값은 비교하여 넣지만, 자기 자신과는 비교하여 넣는 게 아닌듯.

	for (const STRING& 단어 : 목록1)
		cout << 단어 << " ";
	cout << endl;
	
	for (const STRING& 단어 : 목록2)
		cout << 단어 << " ";
	cout << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 4:59:03 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T>		- push_back() O(1)
//		deque<T>		- push_front() / push_back() O(1)
//		list<T>			- node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//						  대표 동작 : sort(), unique(), merge(), splice();
//		forward_list<T>	- 
//						It is intended that forward_list have zero space or time overhead
//						relative to a hand-written C-style singly linked list.
//						Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include <forward_list>
#include<fstream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	forward_list<STRING> cont;

	cout << sizeof cont << endl;	// 8
	//	cont.size ===> 사이즈 제공 안함.
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 5:06:43 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T>		- push_back() O(1)
//		deque<T>		- push_front() / push_back() O(1)
//		list<T>			- node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//						  대표 동작 : sort(), unique(), merge(), splice();
//		forward_list<T>	- 
//						It is intended that forward_list have zero space or time overhead
//						relative to a hand-written C-style singly linked list.
//						Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<vector>
#include<deque>
#include<span>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

void f(span<int> s)
{
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

//---------
int main() 
//---------
{
	int a[]{ 1,2,3,4,5,6,7 };

	// 거꾸로 출력하라.
	f(a);

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-08 오후 5:08:16 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T>		- push_back() O(1)
//		deque<T>		- push_front() / push_back() O(1)
//		list<T>			- node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//						  대표 동작 : sort(), unique(), merge(), splice();
//		forward_list<T>	- 
//						It is intended that forward_list have zero space or time overhead
//						relative to a hand-written C-style singly linked list.
//						Features that would conflict with that goal have been omitted.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<vector>
#include<deque>
#include<span>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

void f(span<int> s)
{
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

//---------
int main() 
//---------
{
	int a[]{ 1,2,3,4,5,6,7 };
	f(a);

	vector<int> v{ begin(a),end(a) };	 // == { &a[0],&a[7] }; 같은 표현
	f(v);

	// deque은 실패함 => contiguouse하지 않기 때문

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-09 오후 10:55:21 금요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 8일 목요일					(10주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	STL Container - Container are objects that store other objects.
//	1. Sequence Containers
//		array<T,N>
//		vector<T>		- push_back() O(1)
//		deque<T>		- push_front() / push_back() O(1)
//		list<T>			- node 기반, 임의의 위치에서 삽입과 삭제 O(1)
//						  대표 동작 : sort(), unique(), merge(), splice();
//		forward_list<T>	- 
//						It is intended that forward_list have zero space or time overhead
//						relative to a hand-written C-style singly linked list.
//						Features that would conflict with that goal have been omitted.
//	span:
//	The class template span describes an object that can refer to a contiguous sequence of objects 
//	with the first element of the sequence at position zero.
//	A span can either have a static extent, in which case the number of elements 
//	in the sequence is known at compile-time and encoded in the type, or a dynamic extent.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<array>
#include<vector>
#include<deque>
#include<span>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

void f(span<int> s)
{
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i << " ";
	cout << endl;
}

//---------
int main() 
//---------
{
	int a[]{ 1,2,3,4,5,6,7 };
	f(a);

	vector<int> v{ begin(a),end(a) };	 // == { &a[0],&a[7] }; 같은 표현
	f(v);

	

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 1:38:57 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	std::string s{ "2025 5 13" };

	cout << s << endl;

	for (char c : s)
		cout << c << " ";
	cout << endl;
	
	//2025 5 13						<< 전체를 찍음
	//2 0 2 5   5   1 3				<< 글자 하나하나를 찍음

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 1:52:49 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//	>  연산자															2025.5.8
//	begin(), end()														2025.5.13
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;
	bool operator<(const STRING& rhs) const;// 2025.05.08

	// 인터페이스 함수들
	size_t size() const;

	//	begin(), end()														2025.5.13
	char* begin()const;
	char* end()const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-13 오후 1:52:49 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//	2025. 5. 13	begin(), end()
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	//if (len != rhs.len)
	//	return false;
	return std::equal(&p[0], &p[len], &rhs.p[0], &rhs.p[rhs.len]);
}

bool STRING::operator<(const STRING& rhs) const				// 2025.05.08
{
	return std::lexicographical_compare(p.get(), p.get() + len,
		rhs.p.get(), rhs.p.get() + rhs.len);
}

size_t STRING::size() const 
{
	return len;
}

//	begin(), end()														2025.5.13
char* STRING::begin()const
{
	return p.get();			// return &p[0];
}
char* STRING::end()const
{
	return p.get() + len;	// return &p[len];
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-13 오후 1:52:49 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	cout << s << endl;

	// syntactic sugar
	for (char c : s)		// 범위(range)는 STL에서 중요한 역할. 해당 줄은 범위 기반 for-loop이기 문에 원소의 처음부터 끝이 어디냐고 오류 띄운 것.
		cout << c << " ";
	// 위 코드는 아래 코드보다 꿀코드? 꿀문장? 꿀문법 여하튼 그럼.
	//for (auto i = s.begin(); i != s.end(); ++i)
	//	cout << *i << " ";
	cout << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 2:10:58 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	반복자는 포인터를 일반화한 것이다.
	ostream_iterator<char> p{ cout };

	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';
	++p;
	*p = '\n';

	save("main.cpp");

	//ABC
	//"2025 1 STL 화56목78 강의저장.txt에 main.cpp을 덧붙였습니다. - 928 bytes"
}


=================================================
저장한 시간: 2025-05-13 오후 2:17:27 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	//	반복자는 포인터를 일반화한 것이다.
	ostream_iterator<char> p{ cout };

	//p.operator*() = 'A';
	p = 'A';
	*p = 'B';
	*p = 'C';
	*p = '\n';
	//	커서는 내가 동작을 시키지 않아도 데이터가 들어가면 자동으로 옆으로 이동
	//	++p 하지 않아도 넘어가는? 그런 거 인듯.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 2:37:43 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	std::string s{ "2025 5 13" };

	// [문제] s의 글자를 거꾸로 출력하라.

	// c만 배웠다면? 또는 자료형이 char s[] {"2025 5 13"}; 이런 식으로 주어졌다면?
	for (int i = s.size(); i != 0; --i)
		cout << s[i - 1];
	cout << endl;
	
	// reverse-begin()/reverse-end() 활용
	for (auto p = s.rbegin(); p != s.rend(); ++p)
		cout << *p;
	cout << endl;

	// 그 외에도 여러 방법 존재

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:02:39 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//	>  연산자															2025.5.8
//	begin(), end()														2025.5.13
//	역방향 반복자는 반드시 클래스로 제공									2025.5.13
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

// 반복자 어댑터 (반복자 사기꾼)
class STRING_Reverse_Iterator {
public:
	STRING_Reverse_Iterator(char* p) : p{ p } {}
	
	char operator*() const{
		return *(p - 1);
	}
	void operator++() {
		--p;
	}
	bool operator==(const STRING_Reverse_Iterator& rhs) const {
		return p == rhs.p;
	}
private:
	char* p;
};

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;
	bool operator<(const STRING& rhs) const;// 2025.05.08

	// 인터페이스 함수들
	size_t size() const;

	//	begin(), end()														2025.5.13
	char* begin()const;
	char* end()const;

	STRING_Reverse_Iterator rbegin()const;
	STRING_Reverse_Iterator rend()const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-13 오후 3:02:39 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.cpp - std::string과 유사한 클래스이다
//				 STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	2025. 4.
//	2025. 5. 1	>> 연산자
//	2025. 5. 13	begin(), end()
//----------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<print>
#include<algorithm>
#include<string>
#include"STRING.h"

// 관찰을 제어하기 위한 변수 추가				// 2025.04.08
bool 관찰{ false };					// 2025.04.08

STRING::STRING()							// 2025.04.08
	: id{++gid}
{
	if(관찰){
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "디폴트생성", len, (void*)this, (void*)p.get());
	}
}

STRING::~STRING()								// 2025.04.08
{
	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "소멸자", len, (void*)this, (void*)p.get());
	}
}

STRING::STRING(const char* s) 
	:id{++gid},len {	strlen(s)}
{
	p.reset();
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), s, len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "생성자(char*)", len, (void*)this, (void*)p.get());
	}
};

STRING::STRING(const STRING& other)			// 2025.04.08
	:id{ ++gid }, len{ other.len }		// 여기에 두 번째 인자를 넣게 되면, 순서가 보장되지 않음
{
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(const STRING& other)	// 2025.04.08
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();								// p.reset()과 다른 점을 공부하자
	p = std::make_unique<char[]>(len);
	memcpy(p.get(), other.p.get(), len);

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "복사할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

//	이동생성과 이동할당연산자				// 2025.04.10
STRING::STRING(STRING&& other)				// && -> rvalue reference
	: id{ ++gid }, len{other.len}
{
	p.reset(other.p.release());

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동생성자", len, (void*)this, (void*)p.get());
	}
}

STRING& STRING::operator=(STRING&& other)
{
	if (this == &other)
		return *this;

	len = other.len;
	p.release();
	p.reset(other.p.release());

	other.len = 0;

	if (관찰) {
		std::println("[{:8}] {:16}, 자원수:{:<10}, 메모리:{:<12}, 자원메모리:{:<12}",
			id, "이동할당연산자", len, (void*)this, (void*)p.get());
	}

	return *this;
}

// 2025. 04. 22 관계연산자들
bool STRING::operator==(const STRING& rhs) const
{
	//if (len != rhs.len)
	//	return false;
	return std::equal(&p[0], &p[len], &rhs.p[0], &rhs.p[rhs.len]);
}

bool STRING::operator<(const STRING& rhs) const				// 2025.05.08
{
	return std::lexicographical_compare(p.get(), p.get() + len,
		rhs.p.get(), rhs.p.get() + rhs.len);
}

size_t STRING::size() const 
{
	return len;
}

//	begin(), end()														2025.5.13
char* STRING::begin()const
{
	return p.get();			// return &p[0];
}
char* STRING::end()const
{
	return p.get() + len;	// return &p[len];
}

STRING_Reverse_Iterator STRING::rbegin()const
{
	return STRING_Reverse_Iterator{ p.get() + len };
}
STRING_Reverse_Iterator STRING::rend()const
{
	return STRING_Reverse_Iterator{ p.get() };
}

std::ostream& operator<<(std::ostream& os, const STRING& str) 
{
	for (int i = 0; i < str.len; ++i)
		os << str.p[i];
	return os;
}

// 2025. 5. 1
std::istream& operator>>(std::istream& is, STRING& str)
{
	std::string s;
	is >> s;
	str.len = s.length();
	str.p.release();
	str.p = std::make_unique<char[]>(str.len);
	memcpy((char*)str.p.get(), s.data(), str.len);
	return is;
}

size_t STRING::gid{};						// 2025.04.0


=================================================
저장한 시간: 2025-05-13 오후 3:02:39 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	// [문제] s의 글자를 거꾸로 출력하라.
	// rbegin(), rend()의 정체 : reverse_iterator

	// 시도 1
	//for (auto p = s.end(); p != s.begin(); --p)
	//	cout << *(p-1);
	//cout << endl;
	
	for (auto i = s.rbegin(); i != s.rend(); ++i)
		cout << *i;
	cout << endl;

	save("STRING.h");
	save("STRING.cpp");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:11:04 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

void f(array<int, 2>::iterator i)
{
	// 어떤 종류
	cout << "array의 반복자 - " << typeid(i).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	array<int, 2> a;
	f(a.begin());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:13:00 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "array의 반복자 - " << typeid(i).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	array<int, 2> a;
	f(a.begin());
	//array의 반복자 - class std::_Array_iterator<int,2>

	vector<int> v;
	f(v.begin());

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:17:07 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "array의 반복자 - " << typeid(반복자::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	array<int, 2> a;
	f(a.begin());
	//array의 반복자 - class std::_Array_iterator<int,2>

	vector<int> v;
	f(v.begin());
	//class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int> > >

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:19:09 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "반복자의 타입 - " << typeid(반복자::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	array<int, 2> a;
	f(a.begin());
	//array의 반복자 - class std::_Array_iterator<int,2>

	vector<int> v;
	f(v.begin());
	//class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int> > >

	f(deque<STRING>::iterator{});
	f(list<int>{}.rbegin());
	f(forward_list<int>::const_iterator{});

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-13 오후 3:19:58 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 13일 목요일					(10주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "반복자의 타입 - " << typeid(반복자::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	array<int, 2> a;
	f(a.begin());
	//array의 반복자 - class std::_Array_iterator<int,2>

	vector<int> v;
	f(v.begin());
	//class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int> > >

	f(deque<STRING>::iterator{});
	f(list<int>{}.rbegin());
	f(forward_list<int>::const_iterator{});
	f(ostream_iterator<char>{cout});
	//	반복자의 타입 - struct std::random_access_iterator_tag
	//	반복자의 타입 - struct std::random_access_iterator_tag
	//	반복자의 타입 - struct std::random_access_iterator_tag
	//	반복자의 타입 - struct std::bidirectional_iterator_tag
	//	반복자의 타입 - struct std::forward_iterator_tag
	//	반복자의 타입 - struct std::output_iterator_tag

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 3:42:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "반복자의 타입 - " << typeid(반복자::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	f(istream_iterator<char>{cin});
	f(ostream_iterator<char>{cout});
	
	f(forward_list<int>{}.begin());
	f(list<STRING>::iterator{});

	f(deque<int>::reverse_iterator{});

	//	반복자의 타입 - struct std::input_iterator_tag
	//	반복자의 타입 - struct std::output_iterator_tag
	//	반복자의 타입 - struct std::forward_iterator_tag
	//	반복자의 타입 - struct std::bidirectional_iterator_tag
	//	반복자의 타입 - struct std::random_access_iterator_tag

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:13:37 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << "반복자의 타입 - " << typeid(반복자::iterator_category).name() << endl;
}

template<>
void f<int*>(int* i) {
	// 어떤 종류
	//cout << "반복자의 타입 - " << typeid(int*::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	//f(1111); // 이거랑 같은 것. 템플릿은 오류가 뜨지 않음?


	//int* p;

	//f( p );

	// 포인터는 .찍고 물어봐도 아무것도 안나오는 바보 자료구조

	// 너 반복자니? 물어보는 애가 concept?

	// Metaprogramming library
	// Metaprogramming이 뭔가요? : 프로그램을 만들어내는 프로그래밍, 소스코드를 만들어주는 프로그래밍.
	// Meta란 뭐냐? 프로그래밍 위에서 놀고 있는 초월적 존재가 Meta
	// Type traits
	// Type traits define compile-time template-based interfaces to query the properties of types.
	// is_pod 는 c++ 20부터 사용하지 않기로 한 것.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:15:17 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	STRING s{ "2025 5 13" };

	//	[문제] 반복자는 종류(6 category)가 있다.
	//	함수 f는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면에 출력하는 함수이다.
	//	다음 코드가 문제없이 실행되게 하자.
	
	int* p;

	f( p );

	// 포인터는 .찍고 물어봐도 아무것도 안나오는 바보 자료구조

	// 너 반복자니? 물어보는 애가 concept?

	// Metaprogramming library
	// Metaprogramming이 뭔가요? : 프로그램을 만들어내는 프로그래밍, 소스코드를 만들어주는 프로그래밍.
	// Meta란 뭐냐? 프로그래밍 위에서 놀고 있는 초월적 존재가 Meta
	// Type traits
	// Type traits define compile-time template-based interfaces to query the properties of types.
	// is_pod 는 c++ 20부터 사용하지 않기로 한 것.

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:16:41 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//---------
int main() 
//---------
{
	// vector는 진짜 메모리가 contiguous
	// deque는 contiguous 아니다.
	// 그런데

	f(vector<int>{}.begin());
	f(deque<int>{}.begin());

	// struct std::random_access_iterator_tag
	// struct std::random_access_iterator_tag
	// 이렇게 나옴.
	// random_access란?
	// 반복자는 메모리를 pointing하는 놈.
	// int 1억개가 담긴 메모리에서 반복자가 나 여기를 포인팅할래. 하면서
	// 랜덤 위치에 접근 하는 것. 아무 자리나 access하는데 동일한 시간이 걸림.(동일한 산술연산? 여하튼)

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:27:39 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<string>
#include<iterator>
#include<array>
#include<vector>
#include<deque>
#include<list>
#include<forward_list>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자>
void f(반복자 i)
{
	// 어떤 종류
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;

	// 벡터는 c++20의 concept을 이용하여 contiguous임을 판정한다.
	cout << "벡터의 반복자 - " << typeid(반복자::iterator_concept).name() << endl;
}

//---------
int main() 
//---------
{
	// vector는 진짜 메모리가 contiguous

	f(vector<int>{}.begin());

	// struct std::random_access_iterator_tag
	// 벡터의 반복자 - struct std::contiguous_iterator_tag
	// 이렇게 나옴.
	// random_access란?
	// 반복자는 메모리를 pointing하는 놈.
	// int 1억개가 담긴 메모리에서 반복자가 나 여기를 포인팅할래. 하면서
	// 랜덤 위치에 접근 하는 것. 아무 자리나 access하는데 동일한 시간이 걸림.(동일한 산술연산? 여하튼)

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:34:07 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<vector>
#include<concepts>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	vector<int> v;

	cout << boolalpha << contiguous_iterator<vector<int>::iterator> << endl;
	// true
	// generics?의 원조는 c++, 디자인 패턴도 마찬가지

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-15 오후 4:34:51 목요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 15일 목요일					(11주 1일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<deque>
#include<concepts>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	deque<int> v;

	cout << boolalpha << contiguous_iterator<deque<int>::iterator> << endl;
	// false
	// generics?의 원조는 c++, 디자인 패턴도 마찬가지

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-20 오후 2:06:48 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//	>  연산자															2025.5.8
//	begin(), end()														2025.5.13
//	역방향 반복자는 반드시 클래스로 제공									2025.5.13
//	반복자도 당연히 클래스로 코딩해야 함									2025.5.15
//	랜덤반복자가 되려면 이러한 연산들 지원									2025.5.20
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING_Iterator {
	// 표준 반복자라면 다음 다섯가지 물음에 대답할 수 있어야 한다
public:
	using difference_type = ptrdiff_t;		// 반복자들 간 거리
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

	STRING_Iterator() = default;		// special 함수
	STRING_Iterator(char* p) : p{ p } {}

	// 반복자라면 최소한 다음 기능을 제공해야 함
	char& operator*() const {
		return *p;
	}

	STRING_Iterator operator++() {
		return ++p;
	}

	bool operator==(const STRING_Iterator& rhs) const {
		return p == rhs.p;
	}

	// 랜덤반복자가 되고 싶다. - 2025.5.20
	difference_type operator-(const STRING_Iterator& rhs) const {
		return p - rhs.p;
	}

	STRING_Iterator operator-(difference_type n) const {
		return p - n;
	}

	STRING_Iterator operator--() {
		return --p;
	}

	STRING_Iterator operator +(difference_type n)const {
		return p + n;
	}
	
	auto operator<=>(const STRING_Iterator& rhs) const {
		return p <=> rhs.p;
	}

private:
	char* p{};
};



// 반복자 어댑터 (반복자 사기꾼)
class STRING_Reverse_Iterator {
public:
	STRING_Reverse_Iterator(char* p) : p{ p } {}
	
	char operator*() const{
		return *(p - 1);
	}
	void operator++() {
		--p;
	}
	bool operator==(const STRING_Reverse_Iterator& rhs) const {
		return p == rhs.p;
	}
private:
	char* p;
};

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;
	bool operator<(const STRING& rhs) const;// 2025.05.08

	// 인터페이스 함수들
	size_t size() const;

	//	begin(), end()														2025.5.13
	STRING_Iterator begin()const;
	STRING_Iterator end()const;

	STRING_Reverse_Iterator rbegin()const;
	STRING_Reverse_Iterator rend()const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-20 오후 2:06:48 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "2025 5 15" };

	//f(s.begin());		// 랜덤반복자라고 출력해야 표준 반복자다!
	// iterator의 표준이 되려면 제공해야 하는 Iterator primitives : iterator_traits
	// iterator_traits :
	// 1. difference_type	Iter::difference_type
	// 2. value_type		Iter::value_type
	// 3. pointer			Iter::pointer
	// 4. reference			Iter::reference
	// 5. iterator_category	Iter::iterator_category

	// 문제없이 실행되게 하라
	sort(s.begin(), s.end());
	// s.end() - s.begin() 에서 걸림.
	// 꺼낸 값이 location이 아님.

	cout << s << endl;		// "  0122555"

	save("STRING.h");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-20 오후 2:09:10 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "2025 5 20" };

	//f(s.begin());		// 랜덤반복자라고 출력해야 표준 반복자다!
	// iterator의 표준이 되려면 제공해야 하는 Iterator primitives : iterator_traits
	// iterator_traits :
	// 1. difference_type	Iter::difference_type
	// 2. value_type		Iter::value_type
	// 3. pointer			Iter::pointer
	// 4. reference			Iter::reference
	// 5. iterator_category	Iter::iterator_category

	// 문제없이 실행되게 하라
	sort(s.begin(), s.end(), [](char a, char b){
		return a > b;
		});
	// 내림차순

	cout << s << endl;		// "  0122555"

//	save("STRING.h");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-20 오후 2:35:34 화요일
=================================================

//----------------------------------------------------------------------------------
//	STRING.h - std::string과 유사한 클래스이다
//			   STL의 container로 동작할 수 있게 코딩해 나간다
//																	2025.4.8 시작
//	>> 연산자															2025.5.1 
//	>  연산자															2025.5.8
//	begin(), end()														2025.5.13
//	역방향 반복자는 반드시 클래스로 제공									2025.5.13
//	반복자도 당연히 클래스로 코딩해야 함									2025.5.15
//	랜덤반복자가 되려면 이러한 연산들 지원									2025.5.20
//----------------------------------------------------------------------------------
#pragma once
#include<memory>
#include<iostream>

class STRING_Iterator {
	// 표준 반복자라면 다음 다섯가지 물음에 대답할 수 있어야 한다
public:
	using difference_type = ptrdiff_t;		// 반복자들 간 거리
	using value_type = char;
	using pointer = char*;
	using reference = char&;
	using iterator_category = std::random_access_iterator_tag;

	STRING_Iterator() = default;		// special 함수
	STRING_Iterator(char* p) : p{ p } {}
	//explicit STRING_Iterator(char* p) : p{p} {} 이렇게 쓰면 다른 타입끼리 더해지지 않음
	// ++p나 --p를 STRING_Iterator{--p}, STRING_Iterator(++p) 이런 식으로 써줘야 함.

	// 반복자라면 최소한 다음 기능을 제공해야 함
	char& operator*() const {
		return *p;
	}

	STRING_Iterator operator++() {
		return ++p;
	}

	bool operator==(const STRING_Iterator& rhs) const {
		return p == rhs.p;
	}

	// 랜덤반복자가 되고 싶다. - 2025.5.20
	difference_type operator-(const STRING_Iterator& rhs) const {
		return p - rhs.p;
	}

	STRING_Iterator operator-(difference_type n) const {
		return p - n;
	}

	STRING_Iterator operator--() {
		return --p;
	}

	STRING_Iterator operator +(difference_type n)const {
		return p + n;
	}
	
	auto operator<=>(const STRING_Iterator& rhs) const {
		return p <=> rhs.p;
	}

private:
	char* p{};
};



// 반복자 어댑터 (반복자 사기꾼)
class STRING_Reverse_Iterator {
public:
	STRING_Reverse_Iterator(char* p) : p{ p } {}
	
	char operator*() const{
		return *(p - 1);
	}
	void operator++() {
		--p;
	}
	bool operator==(const STRING_Reverse_Iterator& rhs) const {
		return p == rhs.p;
	}
private:
	char* p;
};

class STRING {
public:
	STRING();						// 2025.04.08
	~STRING();								// 2025.04.08
											// 관찰을 위해 어쩔 수 없이

	STRING(const char* s);

	//	복사생성과 복사할당연산자
	STRING(const STRING&);					// 2025.04.08
	STRING& operator=(const STRING&);		// 2025.04.08

	//	이동생성과 이동할당연산자				// 2025.04.10
	
	// int a;
	// int* p = &a;		-----> adress a
	// int& a = num;	-----> integer reference of a

	STRING(STRING&&);				// && -> rvalue reference
	STRING& operator=(STRING&&);

	// 2025. 04. 22 관계연산자들
	bool operator==(const STRING& rhs) const;
	bool operator<(const STRING& rhs) const;// 2025.05.08

	// 인터페이스 함수들
	size_t size() const;

	//	begin(), end()														2025.5.13
	STRING_Iterator begin()const;
	STRING_Iterator end()const;

	STRING_Reverse_Iterator rbegin()const;
	STRING_Reverse_Iterator rend()const;

private:
	size_t len{};
	std::unique_ptr<char[]> p{};
	size_t id;									// 2025.04.08

	friend std::ostream& operator<<(std::ostream& os, const STRING& str);

	// 2025. 5. 1
	friend std::istream& operator>>(std::istream& is, STRING& str);

	static size_t gid;						// 2025.04.08
};


=================================================
저장한 시간: 2025-05-20 오후 2:35:34 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	iterator - Iterators are a generalization of pointers that
//	allow a C++ program to work with different data structures in a uniform manner.
//	Iterator는 pointer를 일반화 한 것이다.
//	
//	strong ordering and weak ordering - https://en.wikipedia.org/wiki/Weak_ordering
// 
//	반복자는 클래스로 코딩해야 합니다.
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	char* p;

	save("STRING.h");
	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-20 오후 2:40:02 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());
	unique(s.begin(), s.end());
	// 중복을 지웠는데도 중복이 남아있는 이유: 중복을 없애도 컨테이너의 개수를 없애지 못해서

	cout << s << endl;

	save("main.cpp");
}


=================================================
저장한 시간: 2025-05-20 오후 2:45:20 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());
	unique(s.begin(), s.end());

	cout << s << endl;

	save("main.cpp");

	// 소문자를 입력받아 몇 번째있는 문자인가 출력하자.
	while (true) {
		cout << "소문자? ";
		char c;
		cin >> c;
		auto p = find(s.begin(), s.end(), c);
		if (p != s.end()) {
			cout << distance(s.begin(), p) + 1 << "번째 위치에 있다." << endl;
		}
	}
}


=================================================
저장한 시간: 2025-05-20 오후 2:56:57 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자, class 값>
반복자 my_find(반복자 b, 반복자 e, 값 v)
{
	while (b != e) {
		if (*b == v)
			return b;
		++b;
	}
	return b;
}

//---------
int main() 
//---------
{
	STRING s{ "the quick brown fox jumps over the lazy dog" };

	sort(s.begin(), s.end());
	unique(s.begin(), s.end());

	cout << s << endl;

	save("main.cpp");

	// 소문자를 입력받아 몇 번째있는 문자인가 출력하자.
	while (true) {
		cout << "소문자? ";
		char c;
		cin >> c;
		auto p = my_find(s.begin(), s.end(), c);
		if (p != s.end()) {
			cout << distance(s.begin(), p) + 1 << "번째 위치에 있다." << endl;
		}
	}
}


=================================================
저장한 시간: 2025-05-20 오후 3:01:04 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	save("main.cpp");

	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라.
	auto p = find_if(v.begin(), v.end(), [](int n) {
		return not (n & 1);
	});

	if (p != v.end())
		cout << "처음 만난 짝수는 --- " << *p << endl;
}


=================================================
저장한 시간: 2025-05-20 오후 3:06:35 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자,class Pred>
반복자 my_find_if(반복자 시작, 반복자 끝, Pred f)
{
	for (; 시작 != 끝; ++시작) {
		if (f(*시작))
			return 시작;
	}
	return 끝;
}

//---------
int main() 
//---------
{
	save("main.cpp");

	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };

	// [문제] v에서 처음 나오는 짝수가 무엇인지 출력하라.
	auto p = my_find_if(v.begin(), v.end(), [](int n) {
		return not (n & 1);
	});

	if (p != v.end())
		cout << "처음 만난 짝수는 --- " << *p << endl;
}


=================================================
저장한 시간: 2025-05-20 오후 3:08:23 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

//---------
int main() 
//---------
{
	save("main.cpp");

	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	vector<char> v;

	copy(s.begin(), s.end(), ostream_iterator<char>{cout});
}


=================================================
저장한 시간: 2025-05-20 오후 3:17:15 화요일
=================================================

//------------------------------------------------------------------------------------------------
//	2025 STL 화56목78				5월 20일 화요일					(11주 2일)
//	6월 19일 목요일 15주 2일 - 기말시험
//------------------------------------------------------------------------------------------------
//	반복자와 알고리즘의 관계
//------------------------------------------------------------------------------------------------
#include <iostream>
#include<algorithm>
#include<vector>
#include"STRING.h"
#include "save.h"
using namespace std;

extern bool 관찰;				// 관찰하려면 true로 설정

template<class 반복자, class 목적지반복자>
void my_copy(반복자 b, 반복자 e, 목적지반복자 d)
{
	while (b != e) {
		*d = *b;	//*d++ = *b++;
		++d, ++b;
	}
}

//---------
int main() 
//---------
{
	STRING s{ "반복자를 사용한 알고리즘을 연습 중" };
	vector<char> v{ '1' };

	my_copy(s.begin(), s.end(),back_inserter(v));		//Iterator adaptors

	for (char c : v)
		cout << c;
	cout << endl;
	// 1반복자를 사용한 알고리즘을 연습 중

	//for (int i = 0; i < s.size(); ++i)
	//	cout << v[i];
	//cout << endl;

	save("main.cpp");
}